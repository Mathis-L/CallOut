<script>
    /**
     * @file GamePage.js
     * This file contains the client-side JavaScript logic for the game page of a multiplayer game.
     * It handles Firebase real-time database interactions, game state management, UI updates,
     * player interactions (voting, coin toss), and navigation.
     *
     * Global constants like firebaseConfig, gameId, currentUserId, currentUserPseudo are expected
     * to be defined in the GamePage.html file (e.g., via server-side templating or a script tag).
     */
    
    // --- GLOBAL CONSTANTS (defined in GamePage.html) ---
    // firebaseConfig, gameId, currentUserId, currentUserPseudo
    
    // --- Local Constants ---
    const MIN_CONNECTED_PLAYERS_TO_PROCEED = 2;
    const COIN_TOSS_ANIMATION_DURATION = 1500; // ms (must match CSS animation)
    const POPUP_CLOSE_DELAY = 1500; // ms (time AFTER animation before the popup closes)
    const WRITE_RESULT_DELAY = 1300; // ms (delay BEFORE animation ends for the tosser to write to DB)
    
    // --- Firebase References ---
    let firebaseApp;
    let database;
    let auth;
    let gameRef;
    let playersRef;
    let currentPlayerRef;
    let gameStateRef;
    
    // --- DOM Elements ---
    // Will be populated in initializeGame()
    let playerListElement;
    let gameContent;
    let votingPhaseDiv;
    let resultsPhaseDiv;
    let waitingAreaDiv;
    let currentQuestionElement;
    let playerVoteOptionsDiv;
    let voteStatusElement;
    let resultsDisplayDiv; 
    let nextRoundBtn;
    let readyStatusElement;
    let leaveGameBtn;
    let waitingMessage;
    let pauseMessageElement;
    let coinTossPopup;
    let popupTosserNameElement;
    let popupCoinElement;
    let popupStatusElement;
    let gameErrorPrompt;
    let gameErrorText;
    let gameErrorHomeLink;
    let confessionSelectionPhaseDiv, confessionQuestionPhaseDiv, confessionResultPhaseDiv;
    let playerConfessionTargetOptionsDiv, confessionQuestionTextSelection;
    let confessionAnswerPrompt, confessionQuestionText, confessionJudgmentArea, confessionVerdictDisplay;
    let judgmentConvincedBtn, judgmentNotConvincedBtn, judgmentStatus;
    let nextRoundBtnConfession, readyStatusConfession;
    let confessionSelectionSubtitle, confessionSelectionInstruction;
    let confessionQuestionSubtitle, confessionJudgmentInstruction;  
    let leaveGamePopup, leavePopupTitle, leavePopupLoader, leavePopupMessage, leavePopupActions;
    
    // --- Local State Variables ---
    let localPlayersData = {}; // A local copy of the players object from Firebase
    let localGameState = {}; // A local copy of the 'currentGame' object
    let localFullGameData = {};  // A local copy of the entire lobby object
    let isLeader = false;
    let leaderId = null;
    let hasVotedThisRound = false;
    let isReadyForNext = false;
    let gameStatusListener = null; // Holds the Firebase listener function to allow detachment
    let playersListener = null; // Holds the Firebase listener function to allow detachment
    let connectedPlayersCount = 0;
    let isPopupVisible = false;
    let activeTossTimeoutId = null;  // Timeout for the player tossing the coin
    let popupCloseTimerId = null;  // Timeout for automatically closing the coin toss popup
    let lastDisplayedTosserId = null; // Prevents re-triggering the popup for the same toss
    let resultsAnimationPlayedForRound = null; // Tracks which round's results have been animated
    let confessionModeEnabled = false; 
    
    
    // An object to easily access question lists by their name. In "Questions.html"
    const questionSets = {
      gentle: gentleQuestions,
      mix: mixQuestions,
      extreme: extremeQuestions
    };
    const confessionQuestionSets = {
      gentle: gentleConfessionQuestions,
      mix: mixConfessionQuestions,
      extreme: extremeConfessionQuestions
    };
    
    // Stores the name of the active question set for this game. Default is 'mix'.
    let currentGameQuestionSet = 'mix';
    

    /**
     * Helper object for creating structured game history logs.
     */
    const HistoryLogger = {
       /**
         * Prepares a summary log object for the game's history.
         * @param {object} fullGameData - The localFullGameData object.
         * @param {object} playersData - The localPlayersData object.
         * @returns {object|null} A formatted object ready for a Firebase update.
         */
        prepareSummaryLog(fullGameData, playersData) {
            if (!fullGameData || !playersData) return null;

            // Only keep essential player info for the summary.
            const initialPlayers = {};
            for (const [id, player] of Object.entries(playersData)) {
                if (player.isConnected) { // Snapshot of connected players at game start
                    initialPlayers[id] = {
                        pseudo: player.pseudo,
                        avatarSrc: player.avatarSrc
                    };
                }
            }

            const summaryLog = {
                gameId: gameId,
                leaderId: fullGameData.leaderId,
                startTime: firebase.database.ServerValue.TIMESTAMP,
                settings: {
                    questionSet: fullGameData.selectedQuestionSet || 'mix',
                    confessionModeEnabled: !!fullGameData.confessionModeEnabled
                },
                initialPlayers: initialPlayers
            };

            const path = 'history/summary';
            const updatePayload = {};
            updatePayload[path] = summaryLog;
            return updatePayload;
        },

        /**
         * Formats data from a completed round, including any confession events.
         * @param {object} completedRoundData - The localGameState of the just-finished round.
         * @returns {object|null} A formatted object ready for a Firebase update.
         */
        prepareRoundLog(completedRoundData) {
            if (!completedRoundData || typeof completedRoundData.round !== 'number') return null;

            const roundLog = {
                roundNumber: completedRoundData.round,
                question: completedRoundData.question,
                votes: completedRoundData.votes || null,
                results: completedRoundData.results || null,
                coinTosses: completedRoundData.coinTosses || null,
            };

            if (completedRoundData.confessionResult && completedRoundData.confessionData) {
                console.log(`Logging confession event for round ${completedRoundData.round}`);
                roundLog.confessionEvent = {
                    chooserId: completedRoundData.confessionData.chooserId,
                    targetId: completedRoundData.confessionData.targetId,
                    question: completedRoundData.confessionData.question,
                    judgments: completedRoundData.confessionData.judgments || null,
                    outcome: completedRoundData.confessionResult.outcome,
                    targetBecameImmune: completedRoundData.confessionResult.outcome === 'convaincu'
                };
            }

            const path = `history/rounds/${completedRoundData.round}`;
            const updatePayload = {};
            updatePayload[path] = roundLog;
            return updatePayload;
        }

    };


    // === Confession UI helpers ===

    /**
     * Ensures the ambient background div for confession mode exists, creating it if necessary.
     */
    function ensureConfessionAmbient() {
      if (!document.getElementById('confession-ambient')) {
        const ambient = document.createElement('div');
        ambient.id = 'confession-ambient';
        document.body.appendChild(ambient);
      }
    }

    /**
     * Toggles the CSS class on the body to enable or disable the confession mode theme.
     * @param {boolean} on - True to enable confession mode, false to disable.
     */
    function setConfessionMode(on) {
      ensureConfessionAmbient();
      document.body.classList.toggle('confession-mode', !!on);
    }

    /**
     * Applies CSS classes to highlight the chooser and target players in the top player list.
     */
    function highlightChooserAndTarget() {
      const chooser = localGameState?.confessionData?.chooserId;
      const target  = localGameState?.confessionData?.targetId;
      document.querySelectorAll('#player-list li').forEach(li => {
        li.classList.remove('is-chooser', 'is-target');
        const uid = li.dataset.userId;
        if (!uid) return;
        if (uid === chooser) li.classList.add('is-chooser');
        if (uid === target)  li.classList.add('is-target');
      });
    }

    /**
     * Displays an animated "stamp" for the confession verdict.
     * @param {string} outcome - 'convaincu' or 'pas convaincu'.
     */
    function showVerdictStamp(outcome) {
      const box = document.getElementById('confession-verdict-display');
      if (!box) return;
      const old = box.querySelector('.verdict-stamp');
      if (old) old.remove();
      const stamp = document.createElement('div');
      stamp.className = 'verdict-stamp ' + (outcome === 'convaincu' ? 'approved' : 'rejected');
      stamp.textContent = (outcome === 'convaincu') ? 'Convinced' : 'Not Convinced';
      box.insertAdjacentElement('afterbegin', stamp); // <-- important
    }


     // --- Utility Functions ---

    /**
     * Selects a new, unused question from the current question set.
     * @param {Set<number>} usedIndices - A Set containing indices of used questions.
     * @returns {{question: string, index: number}|null} The new question and its index, or null on failure.
     */
    function getNewQuestion(usedIndices) {
        const activeQuestions = questionSets[currentGameQuestionSet] || questionSets['mix'];
        if (!activeQuestions || activeQuestions.length === 0) {
            console.error(`Question set '${currentGameQuestionSet}' is empty or not found!`);
            return null;
        }
        if (usedIndices.size >= activeQuestions.length) {
            console.log(`All questions from set '${currentGameQuestionSet}' have been used. Resetting.`);
            usedIndices.clear(); 
        }
        let newIndex;
        let attempts = 0; 
        do {
            newIndex = Math.floor(Math.random() * activeQuestions.length);
            attempts++;
        } while (usedIndices.has(newIndex) && attempts < activeQuestions.length * 2);

        if (usedIndices.has(newIndex)) {
            console.error("Failed to find an unused question index.");
            return null; 
        }
        return { question: activeQuestions[newIndex], index: newIndex };
    }

    /**
     * Selects a new, unused confession question.
     * @param {Set<number>} usedIndices - A Set of used indices for confession questions.
     * @returns {{question: string, index: number}|null} The new question and its index, or null.
     */
    function getNewConfessionQuestion(usedIndices) {
        const activeConfessionQuestions = confessionQuestionSets[currentGameQuestionSet] || confessionQuestionSets['mix'];
        if (!activeConfessionQuestions || activeConfessionQuestions.length === 0) return null;
        if (usedIndices.size >= activeConfessionQuestions.length) {
            console.log("Resetting used confession questions.");
            usedIndices.clear();
        }
        let newIndex;
        let attempts = 0;
        do {
            newIndex = Math.floor(Math.random() * activeConfessionQuestions.length);
            attempts++;
        } while (usedIndices.has(newIndex) && attempts < activeConfessionQuestions.length * 2);

        if (usedIndices.has(newIndex)) {
            console.error("Failed to find an unused confession question.");
            return null;
        }
        return { question: activeConfessionQuestions[newIndex], index: newIndex };
    }
    
    /**
     * Gets the base URL of the deployed web app. Essential for creating correct redirect links.
     * @returns {Promise<string>} A promise that resolves with the web app URL.
     */
    function getWebAppUrl() {
        return new Promise((resolve, reject) => {
            if (typeof google !== 'undefined' && google.script && google.script.run) {
                google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getScriptUrl();
            } else {
                console.warn("Contexte GAS non disponible, utilisation de l'origine.");
                resolve(window.location.origin + window.location.pathname);
            }
        });
    }
    
     // --- FIREBASE LISTENERS & ON_DISCONNECT MANAGEMENT ---

    /**
     * Detaches all Firebase listeners and cancels onDisconnect handlers.
     * This is crucial for preventing memory leaks and unwanted writes when the user leaves the page.
     */
     function cleanupListenersAndDisconnect() {
        console.log("Cleanup: Annulation des listeners et de onDisconnect...");
        if (gameRef && gameStatusListener) gameRef.off('value', gameStatusListener);
        if (playersRef && playersListener) playersRef.off('value', playersListener);
        gameStatusListener = null;
        playersListener = null;
        if (activeTossTimeoutId) clearTimeout(activeTossTimeoutId);
        if (popupCloseTimerId) clearTimeout(popupCloseTimerId);
        activeTossTimeoutId = null;
        popupCloseTimerId = null;
        console.log("Timeouts nettoyÃ©s.");
        if (currentPlayerRef) {
            currentPlayerRef.onDisconnect().cancel().catch(err => console.warn("Erreur cancel onDisconnect:", err));
        }
    }
    
    /**
     * Attaches the main Firebase listeners to the game and players references.
     */
    function attachFirebaseListeners() {
        console.log("Attachement des listeners Firebase...");
        if (!gameRef || !playersRef) {
            console.error("Refs Firebase non valides.");
            return;
        }
    
        gameStatusListener = gameRef.on('value', async (snapshot) => {
            console.log("Listener gameRef: DonnÃ©es reÃ§ues.");
            if (!snapshot.exists()) {
                if (gameStatusListener) {
                    console.log("Partie terminÃ©e (ref inexistante).");
                    alert(`Game ${gameId} is over!`);
                    cleanupListenersAndDisconnect();
                    getWebAppUrl().then(baseUrl => window.top.location.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Game ${gameId} is over.`)}`).catch(() => window.top.location.href = window.location.origin);
                }
                return;
            }
    
            const gameData = snapshot.val();

            if (gameData.status === 'finished' && localGameState.phase !== 'finished') {
                console.log("Game status is 'finished'. Displaying end-game popup.");
                cleanupListenersAndDisconnect();

                leavePopupTitle.textContent = "Game Over!";
                leavePopupMessage.textContent = "The game has been ended by the host. You can view the final results.";
                leavePopupLoader.style.display = 'none';
                leavePopupActions.innerHTML = '';
                leaveGamePopup.classList.add('visible');

                try {
                    const baseUrl = await getWebAppUrl();
                    const resultsLink = document.createElement('a');
                    resultsLink.href = `${baseUrl}?page=results&gameId=${gameId}`;
                    resultsLink.textContent = "View Final Results";
                    resultsLink.className = "button-like-link";
                    resultsLink.style.backgroundColor = 'var(--clr-primary-green)';
                    resultsLink.onclick = (e) => { e.preventDefault(); window.top.location.href = resultsLink.href; };
                    
                    leavePopupActions.appendChild(resultsLink);
                    leavePopupActions.style.display = 'flex';
                    leavePopupActions.style.flexDirection = 'column';

                } catch(e) {
                    leavePopupMessage.textContent += " Could not generate results link.";
                }
                
                localGameState.phase = 'finished'; 
                return; 
            }

            localFullGameData = gameData;
            const previousGameState = {...localGameState}; 
            localGameState = gameData.currentGame || {};
            leaderId = gameData.leaderId;
            isLeader = (currentUserId === leaderId);
            currentGameQuestionSet = gameData.selectedQuestionSet || 'mix';
            console.log(`Phase=${localGameState.phase}, Leader=${leaderId}, ActiveToss?`, !!localGameState.activeToss);
            updateGameUIAndState(previousGameState); 
        }, (error) => {
            console.error("Erreur listener gameRef:", error);
            alert("Game server connection error!");
        });
    
        playersListener = playersRef.on('value', (snapshot) => {
            console.log("Listener playersRef: DonnÃ©es reÃ§ues.");
            localPlayersData = snapshot.exists() ? snapshot.val() : {};
            if (!localPlayersData[currentUserId] && playersListener) {
                 console.log("Joueur actuel retirÃ©.");
                 alert("Youâ€™ve been removed from the game!");
                 cleanupListenersAndDisconnect();
                 getWebAppUrl().then(baseUrl => window.top.location.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Youâ€™ve been removed from ${gameId}! See ya!`)}`).catch(() => window.top.location.href = window.location.origin);
                 return;
            }
            updateGameUIAndState(); 
        }, (error) => {
            console.error("Erreur listener playersRef:", error);
            alert("Player list connection failed! ");
        });
    }
    
    
     // --- UI Update Functions ---

    /**
     * Renders the list of players at the top of the page, including their status.
     */
     function updatePlayerListUI() {
        if (!playerListElement) return;
        playerListElement.innerHTML = '';
        if (!localPlayersData || Object.keys(localPlayersData).length === 0) {
            playerListElement.innerHTML = '<li class="loading">No players... yet!</li>';
            return;
        }
        const phase = localGameState?.phase;
        const votes = localGameState?.votes || {};
        const readyForNext = localGameState?.readyForNextRound || {};
        const judgments = localGameState.confessionData?.judgments || {};

        Object.entries(localPlayersData).forEach(([id, player]) => {
            const li = document.createElement('li');
            li.dataset.userId = id;
            const isConnected = player.isConnected === true;
             if (player.avatarSrc) {
                 const img = document.createElement('img');
                 img.src = player.avatarSrc;
                 img.alt = "Avatar";
                 img.classList.add('player-avatar');
                 li.appendChild(img);
             }
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('player-name-list');
            nameSpan.textContent = player.pseudo || 'Anonyme';
            li.appendChild(nameSpan); 
            if (!isConnected) li.classList.add('disconnected');
            if (id === leaderId) li.classList.add('is-leader');
            if (id === currentUserId) li.classList.add('is-self');
    
            const statusIndicator = document.createElement('span');
            statusIndicator.className = 'status-indicator';
            if (isConnected) {
                let isPlayerReadyOrVoted = false;
                if (phase === 'voting' && votes[id]) isPlayerReadyOrVoted = true;
                else if ((phase === 'results' || phase === 'confession_result') && readyForNext[id]) isPlayerReadyOrVoted = true;
                else if (phase === 'confession_question' && judgments[id]) isPlayerReadyOrVoted = true;
                if (isPlayerReadyOrVoted) statusIndicator.classList.add('ready');
            }
            li.appendChild(statusIndicator);
            playerListElement.appendChild(li);
        });
        if (leaveGameBtn) leaveGameBtn.textContent = isLeader ? "Finish Game" : "Bail Out!";
        highlightChooserAndTarget();
    }
    
    /**
     * Shows a specific game phase DIV and hides all others.
     * @param {string} phaseToShow - The ID of the phase to show (e.g., 'voting', 'results').
     */
    function showPhase(phaseToShow) {
        console.log("Affichage de la phase:", phaseToShow);
         const phases = [
            votingPhaseDiv, resultsPhaseDiv, waitingAreaDiv, 
            confessionSelectionPhaseDiv, confessionQuestionPhaseDiv, confessionResultPhaseDiv
        ];
        phases.forEach(phaseDiv => {
            if (phaseDiv) {
                const isTargetPhase = phaseDiv.id === `${phaseToShow}-phase` || phaseDiv.id === `${phaseToShow}-area`;
                phaseDiv.classList.toggle('active', isTargetPhase);
            }
        });
        pauseMessageElement.style.display = localGameState.isPaused ? 'block' : 'none'; 
        const elementToShow = document.getElementById(`${phaseToShow}-phase`) || document.getElementById(`${phaseToShow}-area`);
        if (!elementToShow) {
            console.warn("Phase inconnue:", phaseToShow);
             if (waitingAreaDiv) waitingAreaDiv.classList.add('active');
             if (waitingMessage) waitingMessage.textContent = "Unknown status...";
        }
    }
    
     /**
     * Renders the UI for the 'voting' phase.
     */
    function renderVotingPhase() {
        currentQuestionElement.textContent = localGameState.question || "Loading...";
        playerVoteOptionsDiv.innerHTML = '';
        hasVotedThisRound = !!(localGameState.votes && localGameState.votes[currentUserId]);
        const myVoteTargetId = localGameState.votes?.[currentUserId];

         // Create a vote button for each other player.
        Object.entries(localPlayersData).forEach(([id, player]) => {
            if (id === currentUserId) return; // Can't vote for yourself
            const isTargetConnected = player.isConnected === true;
            const btn = document.createElement('button');
            btn.classList.add('player-vote-btn');
            btn.dataset.targetUserId = id;
            if (player.avatarSrc) {
                const img = document.createElement('img');
                img.src = player.avatarSrc;
                img.alt = "Avatar";
                img.classList.add('player-avatar');
                btn.appendChild(img);
            }
            const nameSpan = document.createElement('span'); 
            nameSpan.classList.add('player-name-vote');
            nameSpan.textContent = player.pseudo || 'Anonyme';
            if (!isTargetConnected) {
               btn.classList.add('target-disconnected');
               nameSpan.textContent += " (Offline)"; 
            }
            btn.appendChild(nameSpan); 
            btn.disabled = hasVotedThisRound;
            if (hasVotedThisRound && myVoteTargetId === id) { btn.classList.add('voted-for'); }
            btn.addEventListener('click', handleVoteClick);
            playerVoteOptionsDiv.appendChild(btn);
        });

        // Update the status message at the bottom.
        const votes = localGameState.votes || {};
        const connectedVotesCount = Object.keys(votes).filter(id => localPlayersData[id]?.isConnected).length;
        if (hasVotedThisRound) {
            const votedForPseudo = localPlayersData[myVoteTargetId]?.pseudo || 'a player';
            const remainingVotes = Math.max(0, connectedPlayersCount - connectedVotesCount);
            voteStatusElement.textContent = `Youâ€™ve voted for ${votedForPseudo}! Waiting on ${remainingVotes} more vote(s)...`;
        } else {
            voteStatusElement.textContent = `Vote time! ${connectedVotesCount}/${connectedPlayersCount} players voted!`;
        }
    }
    
    /**
     * Renders the UI for the 'results' phase, including vote counts and animations.
     */
    function renderResultsPhase() {
        resultsDisplayDiv.innerHTML = '';
        const results = localGameState.results || {};
        const readyForNext = localGameState.readyForNextRound || {};
        const coinTossesData = localGameState.coinTosses || {};
        const activeToss = localGameState.activeToss;
        isReadyForNext = !!readyForNext[currentUserId];
        const currentRound = localGameState.round; 

        // Only play the reveal animation once per round.
        const playAnimation = resultsAnimationPlayedForRound !== currentRound;
        if (playAnimation) {
            console.log(`PremiÃ¨re apparition des rÃ©sultats pour la manche ${currentRound}. Animation !`);
            resultsAnimationPlayedForRound = currentRound; 
        }
        if (Object.keys(results).length === 0) {
            resultsDisplayDiv.innerHTML = '<p>No votes recorded...</p>';
            if (playAnimation) resultsAnimationPlayedForRound = currentRound;
        } else {
            const sortedResults = Object.entries(results).sort(([, a], [, b]) => b - a);
            let maxVotes = 0;
            sortedResults.forEach(([, count]) => { if (count > maxVotes) maxVotes = count; });
            const voteScale = maxVotes > 0 ? maxVotes : 1;
            const animationDelayIncrement = 1000; 
            sortedResults.forEach(([playerId, count], index) => {
                const player = localPlayersData[playerId];
                if (!player) return;
                const resultItemDiv = document.createElement('div');
                resultItemDiv.className = 'result-item';
                resultItemDiv.dataset.playerId = playerId;
                if (!player.isConnected) resultItemDiv.classList.add('disconnected-result');
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'result-score';
                const scorePlayer = document.createElement('div');
                scorePlayer.className = 'result-score-player';
                if (player.avatarSrc) {
                  const img = document.createElement('img');
                  img.src = player.avatarSrc;
                  img.alt = "Avatar";
                  img.classList.add('player-avatar');
                  scorePlayer.appendChild(img); 
                }
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name-result';
                nameSpan.textContent = player.pseudo || 'Inconnu';
                if (!player.isConnected) nameSpan.textContent += " (DÃ©co)";
                const countStrong = document.createElement('strong');
                countStrong.classList.add('player-vote-count');
                countStrong.textContent = `${count} vote${count > 1 ? 's' : ''}`;
                scorePlayer.appendChild(nameSpan);
                scoreDiv.appendChild(scorePlayer);
                scoreDiv.appendChild(countStrong);
                resultItemDiv.appendChild(scoreDiv);
                const voteBarContainer = document.createElement('div');
                voteBarContainer.className = 'vote-bar-container';
                const voteBarFill = document.createElement('div');
                voteBarFill.className = 'vote-bar-fill';
                const barWidthPercentage = (count / voteScale) * 100;
                voteBarContainer.appendChild(voteBarFill);
                resultItemDiv.appendChild(voteBarContainer);
                if (count > 0) {
                    const tossSectionDiv = document.createElement('div'); tossSectionDiv.className = 'coin-toss-section';
                    const statusSpan = document.createElement('span'); statusSpan.className = 'coin-toss-status';
                    const tossData = coinTossesData[playerId];
                    let canToss = (currentUserId === playerId && !tossData && !activeToss);
                    if (tossData) {
                        statusSpan.textContent = `Results : ${tossData.result === 'HEADS' ? 'HEADS !' : 'TAILS !'}`;
                    } else if (activeToss) {
                         statusSpan.textContent = activeToss.tossingPlayerId === playerId ? "Tossing..." : `Hold tight! ${activeToss.tossingPlayerPseudo} is about to toss... `;
                    } else {
                        statusSpan.textContent = (currentUserId === playerId) ? "Ready to toss?" : "Waiting for the toss...";
                    }
                    tossSectionDiv.appendChild(statusSpan);
                    if (canToss) {
                        const tossBtn = document.createElement('button'); tossBtn.className = 'toss-trigger-button'; tossBtn.dataset.targetPlayerId = playerId; tossBtn.textContent = 'Toss the coin!';
                        tossSectionDiv.appendChild(tossBtn);
                    }
                    resultItemDiv.appendChild(tossSectionDiv);
                    if (tossData && tossData.revealVotes) {
                        const revealedDiv = document.createElement('div'); revealedDiv.className = 'revealed-votes';
                        const ul = document.createElement('ul'); const votes = localGameState.votes || {}; let revealedCount = 0;
                        Object.entries(votes).forEach(([voterId, votedId]) => {
                            if (votedId === playerId) {
                                const voter = localPlayersData[voterId]; const voterName = voter?.pseudo || 'Player left';
                                const li = document.createElement('li'); li.innerHTML = `Voter: <strong>${voterName}</strong> ${!voter?.isConnected ? '(Offline)' : ''}`;
                                ul.appendChild(li); revealedCount++;
                            }
                        });
                        revealedDiv.innerHTML = `<h6>Votes revealed:</h6>`;
                        if (revealedCount > 0) revealedDiv.appendChild(ul); else revealedDiv.innerHTML += `<i>Nobody voted for ${player.pseudo}!</i>`;
                        revealedDiv.style.display = 'block'; resultItemDiv.appendChild(revealedDiv);
                    } else if (tossData && !tossData.revealVotes) {
                        const revealedDiv = document.createElement('div'); revealedDiv.className = 'revealed-votes';
                        revealedDiv.innerHTML = `<h6>Results :</h6><i>Votes remain secret (Tails)! ðŸ¤«</i>`;
                        revealedDiv.style.display = 'block'; resultItemDiv.appendChild(revealedDiv);
                    }
                }
                resultsDisplayDiv.appendChild(resultItemDiv);
                if (playAnimation) {
                    const currentDelay = index * animationDelayIncrement;
                    setTimeout(() => {
                        resultItemDiv.classList.add('appear'); 
                        setTimeout(() => { voteBarFill.style.width = `${barWidthPercentage}%`; }, 100);
                    }, currentDelay);
                } else {
                    resultItemDiv.style.opacity = 1;
                    resultItemDiv.style.transform = 'translateY(0)';
                    voteBarFill.style.width = `${barWidthPercentage}%`;
                }
            });
        }
        nextRoundBtn.disabled = isReadyForNext;
        nextRoundBtn.textContent = isReadyForNext ? "Ready!" : "Ready for the next round!";
        nextRoundBtn.classList.toggle('ready', isReadyForNext);
        const connectedReadyCount = Object.keys(readyForNext).filter(id => localPlayersData[id]?.isConnected).length;
        readyStatusElement.textContent = `${connectedReadyCount} / ${connectedPlayersCount} players are ready !`;
    }
    
    // --- Coin Toss Popup Functions ---

    /**
     * Displays and animates the coin toss popup.
     * @param {string} tosserId - The ID of the player tossing the coin.
     * @param {string} tosserPseudo - The name of the player.
     */
    function showCoinTossPopup(tosserId, tosserPseudo) {
        if (!coinTossPopup || isPopupVisible) {
            if (isPopupVisible && lastDisplayedTosserId !== tosserId) {
                 popupTosserNameElement.innerHTML = `<strong>${tosserPseudo}</strong> toss the coin... `;
                 lastDisplayedTosserId = tosserId;
            }
            return;
        }
        console.log(`Affichage popup pour ${tosserPseudo} (ID: ${tosserId})`);
        lastDisplayedTosserId = tosserId; 
        popupTosserNameElement.innerHTML = ''; 
        const tosserData = localPlayersData[tosserId];
        if (tosserData && tosserData.avatarSrc) {
            const img = document.createElement('img');
            img.src = tosserData.avatarSrc;
            img.alt = "Avatar";
            img.classList.add('player-avatar-popup'); 
            popupTosserNameElement.appendChild(img);
        }
        const nameText = document.createElement('span'); 
        nameText.innerHTML = `<strong>${tosserPseudo}</strong> toss the coin...`;
        popupTosserNameElement.appendChild(nameText);
        popupStatusElement.textContent = "Tossing...";
        popupCoinElement.style.transform = 'rotateX(45deg)'; 
        popupCoinElement.style.display = 'block';
        popupCoinElement.classList.remove('animate');
        void popupCoinElement.offsetWidth; 
        popupCoinElement.classList.add('animate');
        coinTossPopup.classList.add('visible');
        isPopupVisible = true;
        clearTimeout(popupCloseTimerId); 
        popupCloseTimerId = setTimeout(hideCoinTossPopup, COIN_TOSS_ANIMATION_DURATION + POPUP_CLOSE_DELAY);
    }

    /**
     * Hides the coin toss popup.
     */
    function hideCoinTossPopup() {
        if (!isPopupVisible) return;
        console.log("Fermeture popup lancer.");
        clearTimeout(popupCloseTimerId); 
        popupCloseTimerId = null;
        lastDisplayedTosserId = null; 
        popupCoinElement.classList.remove('animate');
        coinTossPopup.classList.remove('visible');
        setTimeout(() => {
            if (!coinTossPopup.classList.contains('visible')) {
                 popupCoinElement.style.display = 'none';
            }
        }, 300);
        isPopupVisible = false;
    }
    
     /**
     * Updates the text and coin position in the popup after the animation is finished.
     * @param {string} resultText - The text to display (e.g., "Result: HEADS!").
     * @param {string} result - The result ('HEADS' or 'TAILS') to set the final coin rotation.
     */
    function updatePopupWithFinalResult(resultText, result) {
        if (isPopupVisible) {
            console.log(`Popup: Affichage rÃ©sultat final: ${resultText}`);
            popupStatusElement.textContent = resultText;
            popupCoinElement.classList.remove('animate'); 
            const finalRotation = result === 'HEADS' ? 'rotateX(45deg)' : 'rotateX(225deg)';
            popupCoinElement.style.transform = finalRotation;
        } else {
            console.warn("Tentative d'afficher rÃ©sultat final dans popup non visible.");
        }
    }
    
    // --- User Event Handlers ---

    /**
     * Handles the flow for a player clicking the "Bail Out!" or "Finish Game" button.
     */
    async function leaveGameVoluntarily() { 
        const iAmLeader = (currentUserId === leaderId);
        leaveGameBtn.disabled = true;

        // Show the confirmation popup
        leavePopupLoader.style.display = 'none';
        leavePopupActions.style.display = 'flex';
        leavePopupActions.style.flexDirection = 'column';
        leavePopupActions.innerHTML = ''; // Always clear previous actions
        leaveGamePopup.classList.add('visible');

        // Create a common "Cancel" button
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = "Cancel";
        cancelBtn.style.backgroundColor = 'var(--clr-disabled-bg)';
        cancelBtn.style.color = 'var(--clr-text-dark)';
        cancelBtn.style.marginTop = '10px';
        cancelBtn.onclick = () => {
            leaveGamePopup.classList.remove('visible');
            leaveGameBtn.disabled = false; // Re-enable the main button
        };

        if (iAmLeader) {
            // --- Confirmation flow for the Game Leader ---
            leavePopupTitle.textContent = "Finish Game?";
            leavePopupMessage.textContent = "Are you sure you want to end the game for everyone?";

            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = "Yes, End It";
            confirmBtn.style.backgroundColor = 'var(--clr-error)';
            
            confirmBtn.onclick = async () => {
                 // Show loading state
                leavePopupMessage.textContent = "Ending the game, please wait...";
                leavePopupActions.style.display = 'none';
                leavePopupLoader.style.display = 'block';

                cleanupListenersAndDisconnect();
                
                try {
                    const baseUrl = await getWebAppUrl();
                    // Set the game status to 'finished' which all other players will detect.
                    await gameRef.update({ 
                        status: 'finished',
                        endTime: firebase.database.ServerValue.TIMESTAMP 
                    });

                    // Display final success message
                    leavePopupTitle.textContent = "Game Ended";
                    leavePopupMessage.textContent = "The game has been successfully ended. You can now view the final results.";
                    leavePopupLoader.style.display = 'none';
                    
                    const resultsLink = document.createElement('a');
                    resultsLink.href = `${baseUrl}?page=results&gameId=${gameId}`;
                    resultsLink.textContent = "View Final Results";
                    resultsLink.className = "button-like-link";
                    resultsLink.style.backgroundColor = 'var(--clr-primary-green)';
                    resultsLink.onclick = (e) => { e.preventDefault(); window.top.location.href = resultsLink.href; };

                    leavePopupActions.innerHTML = '';
                    leavePopupActions.appendChild(resultsLink);
                    leavePopupActions.style.display = 'flex';

                } catch (error) {
                    console.error("Error ending game:", error);
                    leavePopupTitle.textContent = "Error!";
                    leavePopupMessage.textContent = `An error occurred: ${error.message}.`;
                    leavePopupLoader.style.display = 'none';
                }
            };

            leavePopupActions.appendChild(confirmBtn);
            leavePopupActions.appendChild(cancelBtn);
        
        } else {
            // --- Confirmation flow for regular players ---
            leavePopupTitle.textContent = "Leave Game?";
            leavePopupMessage.textContent = "Are you sure you want to bail out? You won't be able to rejoin this game.";

            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = "Yes, I'm Out";
            confirmBtn.style.backgroundColor = 'var(--clr-error)';

            confirmBtn.onclick = async () => {
                leavePopupMessage.textContent = "Processing your request...";
                leavePopupActions.style.display = 'none';
                leavePopupLoader.style.display = 'block';

                cleanupListenersAndDisconnect();
                
                try {
                    const baseUrl = await getWebAppUrl();
                     // Simply remove the player's own data from Firebase.
                    if (currentPlayerRef) await currentPlayerRef.remove();
                    
                    leavePopupTitle.textContent = "You've Left!";
                    leavePopupMessage.textContent = "You have successfully left the game.";
                    leavePopupLoader.style.display = 'none';

                    const homeLink = document.createElement('a');
                    homeLink.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Youâ€™ve left game ${gameId}!`)}`;
                    homeLink.textContent = "Return to Home";
                    homeLink.className = "button-like-link";
                    homeLink.style.backgroundColor = 'var(--clr-primary-green)';
                    homeLink.onclick = (e) => { e.preventDefault(); window.top.location.href = homeLink.href; };
                    
                    leavePopupActions.innerHTML = '';
                    leavePopupActions.appendChild(homeLink);
                    leavePopupActions.style.display = 'flex';

                } catch (error) {
                    console.error("Error leaving the game:", error);
                    leavePopupTitle.textContent = "Error!";
                    leavePopupMessage.textContent = `An error occurred: ${error.message}. Please try returning home.`;
                    leavePopupLoader.style.display = 'none';

                    const homeLink = document.createElement('a');
                    homeLink.href = window.location.origin;
                    homeLink.textContent = "Return to Home";
                    homeLink.className = "button-like-link";
                    homeLink.style.backgroundColor = 'var(--clr-error)';
                    homeLink.onclick = (e) => { e.preventDefault(); window.top.location.href = homeLink.href; };

                    leavePopupActions.innerHTML = '';
                    leavePopupActions.appendChild(homeLink);
                    leavePopupActions.style.display = 'flex';
                }
            };
            
            leavePopupActions.appendChild(confirmBtn);
            leavePopupActions.appendChild(cancelBtn);
        }
    }
    
    /**
     * Handles a click on a player vote button.
     * @param {Event} event - The click event.
     */
    function handleVoteClick(event) { 
        const clickedButton = event.target.closest('.player-vote-btn'); 
        if (!clickedButton || clickedButton.disabled || hasVotedThisRound) return;
        const targetUserId = clickedButton.dataset.targetUserId;
        if (!targetUserId) return;

        // Disable all buttons immediately to prevent double-voting.
        document.querySelectorAll('.player-vote-btn').forEach(btn => btn.disabled = true);
        clickedButton.classList.add('voted-for');
        // Write the vote to Firebase.
        gameStateRef.child('votes').child(currentUserId).set(targetUserId)
            .catch(error => {
                console.error("Firebase vote write FAILED:", error);
                alert("Oops! Error recording your vote! Please try again!");
                // Re-enable buttons if the write failed.
                 document.querySelectorAll('.player-vote-btn').forEach(btn => {
                     if (!(localGameState.votes && localGameState.votes[currentUserId])) btn.disabled = false;
                 });
                 clickedButton.classList.remove('voted-for'); 
            });
    }
    
    /**
     * Handles a click on the "Next Round" button.
     */
    function handleNextRoundClick() { 
        if (isReadyForNext) return;
        const isConfessionResultPhase = localGameState.phase === 'confession_result';
        const buttonToUpdate = isConfessionResultPhase ? nextRoundBtnConfession : nextRoundBtn;
        buttonToUpdate.disabled = true;
        buttonToUpdate.textContent = "Ready !";
        buttonToUpdate.classList.add('ready');
        // Set the player's 'ready' status in Firebase.
        gameStateRef.child('readyForNextRound').child(currentUserId).set(true)
            .catch(error => {
                console.error("Erreur envoi 'PrÃªt':", error);
                alert("Error recording 'Ready' status.");
                buttonToUpdate.disabled = false;
                buttonToUpdate.textContent = "Ready for the next round";
                buttonToUpdate.classList.remove('ready');
            });
    }
    
    /**
     * Handles a click on a "Toss the coin!" button.
     * @param {Event} event - The click event.
     */
    function handleCoinTossTriggerClick(event) { 
        // Use event delegation to catch clicks on buttons inside the results area.
         if (!event.target.matches('.toss-trigger-button')) return; 
         const button = event.target;
         const targetPlayerId = button.dataset.targetPlayerId;
         // A player can only toss for themselves, and only if a toss isn't already in progress.
         if (currentUserId !== targetPlayerId || (localGameState.coinTosses && localGameState.coinTosses[targetPlayerId]) || localGameState.activeToss) {
              if(localGameState.activeToss) alert(`Wait for ${localGameState.activeToss.tossingPlayerPseudo}'s toss to finish...`);
              return;
         }
         button.disabled = true;
         button.textContent = 'Tossing...';
         // Set the 'activeToss' state in Firebase, which all players will see.
         const tossInitiationData = {
             tossingPlayerId: currentUserId,
             tossingPlayerPseudo: currentUserPseudo, 
             startTime: firebase.database.ServerValue.TIMESTAMP
         };
         gameStateRef.child('activeToss').set(tossInitiationData)
             .catch(error => {
                 console.error("Erreur lors du dÃ©clenchement du lancer:", error);
                 alert("Error during coin toss.");
                 if(button) { button.disabled = false; button.textContent = 'Toss the coin!'; }
             });
    }

    /**
     * Displays a critical error message and hides the main game interface.
     * @param {string} errorMessage - The error message to display.
     */
    function showGameErrorAndRedirect(errorMessage) {
        console.error("Displaying critical game error:", errorMessage);
        const playerListArea = document.getElementById('player-list-area');
        const gameCard = document.querySelector('.game-card');
        if (playerListArea) playerListArea.style.display = 'none';
        if (gameCard) gameCard.style.display = 'none';
        gameErrorText.textContent = `Oops! ${errorMessage}`;
        gameErrorPrompt.style.display = 'block';
        getWebAppUrl().then(baseUrl => {
            gameErrorHomeLink.href = `${baseUrl}?page=home&error=${encodeURIComponent("Disconnected from game.")}`;
        }).catch(() => { gameErrorHomeLink.href = window.location.origin; });
    }
    
    // --- Main Game Logic & State Machine ---

    /**
     * Initializes the game page, sets up Firebase, and attaches event listeners.
     */
    function initializeGame() {
        // --- Populate DOM element references ---
        playerListElement = document.getElementById('player-list');
        gameContent = document.getElementById('game-content');
        votingPhaseDiv = document.getElementById('voting-phase');
        resultsPhaseDiv = document.getElementById('results-phase');
        resultsDisplayDiv = document.getElementById('results-display');
        waitingAreaDiv = document.getElementById('waiting-area');
        currentQuestionElement = document.getElementById('current-question');
        playerVoteOptionsDiv = document.getElementById('player-vote-options');
        voteStatusElement = document.getElementById('vote-status');
        nextRoundBtn = document.getElementById('next-round-btn');
        readyStatusElement = document.getElementById('ready-status');
        leaveGameBtn = document.getElementById('leaveGameBtn');
        waitingMessage = document.getElementById('waiting-message');
        pauseMessageElement = document.getElementById('pause-message');
        coinTossPopup = document.getElementById('coin-toss-popup');
        popupTosserNameElement = document.getElementById('popup-tosser-name');
        popupCoinElement = document.getElementById('popup-coin');
        popupStatusElement = document.querySelector('#coin-toss-popup .popup-status'); 
        gameErrorPrompt = document.getElementById('game-error-prompt');
        gameErrorText = document.getElementById('game-error-text');
        gameErrorHomeLink = document.getElementById('game-error-home-link');
        confessionSelectionPhaseDiv = document.getElementById('confession-selection-phase');
        confessionQuestionPhaseDiv = document.getElementById('confession-question-phase');
        confessionResultPhaseDiv = document.getElementById('confession-result-phase');
        playerConfessionTargetOptionsDiv = document.getElementById('player-confession-target-options');
        confessionQuestionTextSelection = document.getElementById('confession-question-text-selection');
        confessionAnswerPrompt = document.getElementById('confession-answer-prompt');
        confessionJudgmentArea = document.getElementById('confession-judgment-area');
        confessionVerdictDisplay = document.getElementById('confession-verdict-display');
        judgmentConvincedBtn = document.getElementById('judgment-convinced-btn');
        judgmentNotConvincedBtn = document.getElementById('judgment-not-convinced-btn');
        judgmentStatus = document.getElementById('judgment-status');
        nextRoundBtnConfession = document.getElementById('next-round-btn-confession');
        readyStatusConfession = document.getElementById('ready-status-confession');
        confessionQuestionText = document.getElementById('confession-question-text');
        confessionSelectionSubtitle = document.getElementById('confession-selection-subtitle');
        confessionSelectionInstruction = document.getElementById('confession-selection-instruction');
        confessionQuestionSubtitle = document.getElementById('confession-question-subtitle');
        confessionJudgmentInstruction = document.getElementById('confession-judgment-instruction');
        leaveGamePopup = document.getElementById('leave-game-popup');
        leavePopupTitle = document.getElementById('leave-popup-title');
        leavePopupLoader = document.getElementById('leave-popup-loader');
        leavePopupMessage = document.getElementById('leave-popup-message');
        leavePopupActions = document.getElementById('leave-popup-actions');


        if(!resultsDisplayDiv) {
            alert("Critical error: Game interface failed to load.");
            return;
        }
        showPhase('waiting');
        waitingMessage.textContent = "Connecting to game server...";
        try {
             // Initialize Firebase
            if (!firebase.apps.length) firebaseApp = firebase.initializeApp(firebaseConfig);
            else firebaseApp = firebase.app();
            database = firebase.database();
            auth = firebase.auth(); 
            gameRef = database.ref(`lobbies/${gameId}`);
            playersRef = database.ref(`lobbies/${gameId}/players`);
            currentPlayerRef = playersRef.child(currentUserId);
            gameStateRef = database.ref(`lobbies/${gameId}/currentGame`);

            // This is the main entry point for connecting the client to Firebase.
            auth.onAuthStateChanged(user => {
                if (user) {
                    if (user.uid === currentUserId) {
                        // 1. Set up the onDisconnect handler first. This is a "last will and testament"
                        // that the Firebase servers will execute if the client disconnects ungracefully.
                        currentPlayerRef.onDisconnect().update({
                            isConnected: false,
                            disconnectedAt: firebase.database.ServerValue.TIMESTAMP
                        }).catch(error => console.error("Could not set onDisconnect handler:", error));

                        // 2. Listen to the local client's connection state to Firebase.
                        // This handles graceful reconnections (e.g., switching from WiFi to cellular).
                        const connectedRef = database.ref('.info/connected');
                        connectedRef.on('value', (snap) => {
                            if (snap.val() === true) {
                                // When we connect (or reconnect), we write our status as 'true'.
                                // This overwrites the 'false' from onDisconnect if it was a temporary disconnection.
                                console.log("Connection active. Forcing isConnected: true.");
                                currentPlayerRef.update({
                                    isConnected: true,
                                    lastSeen: firebase.database.ServerValue.TIMESTAMP
                                });
                            }
                            // No 'else' is needed because onDisconnect handles the 'false' state
                        });

                        // 3. Attach the game-specific data listeners.
                        attachFirebaseListeners();

                    } else {
                        showGameErrorAndRedirect("Session invalid. Please rejoin from home.");
                    }
                } else {
                    showGameErrorAndRedirect("Authentication expired. Please rejoin from home.");
                }
            });
        } catch (error) {
            showGameErrorAndRedirect(`Initialization failed: ${error.message}`);
        }

        // --- Attach UI event listeners ---
        nextRoundBtn.addEventListener('click', handleNextRoundClick);
        nextRoundBtnConfession.addEventListener('click', handleNextRoundClick);
        leaveGameBtn.addEventListener('click', leaveGameVoluntarily);
        resultsDisplayDiv.addEventListener('click', handleCoinTossTriggerClick);
        judgmentConvincedBtn.addEventListener('click', () => handleJudgmentClick('convaincu'));
        judgmentNotConvincedBtn.addEventListener('click', () => handleJudgmentClick('pas convaincu'));
    }
    
     /**
     * The main state-management function. It's called whenever data from Firebase changes.
     * It updates the UI and, if the current player is the leader, triggers game state transitions.
     * @param {object} [previousGameState={}] - A copy of the game state before the latest update.
     */
    function updateGameUIAndState(previousGameState = {}) {
        if (!localPlayersData) return;

         // --- Global Updates ---
        connectedPlayersCount = Object.values(localPlayersData).filter(p => p.isConnected === true).length;
        updatePlayerListUI(); 
        confessionModeEnabled = !!localFullGameData.confessionModeEnabled;
        const currentPhase = localGameState.phase || 'waiting_start';

        // --- Coin Toss Logic ---
        // Manages the display and timing of the coin toss popup based on Firebase state.
        const activeToss = localGameState.activeToss;
        const previousActiveToss = previousGameState.activeToss;
        const coinTosses = localGameState.coinTosses || {};
        if (activeToss && (!previousActiveToss || previousActiveToss.tossingPlayerId !== activeToss.tossingPlayerId)) {
             // A new toss has started.
            showCoinTossPopup(activeToss.tossingPlayerId, activeToss.tossingPlayerPseudo || 'A player');
            // If *I* am the one tossing, I'm responsible for writing the result after a delay.
            if (activeToss.tossingPlayerId === currentUserId && !activeTossTimeoutId) {
                activeTossTimeoutId = setTimeout(() => {
                    const result = Math.random() < 0.5 ? 'HEADS' : 'TAILS';
                    const revealVotes = (result === 'HEADS');
                    const resultText = `Result: ${result}!`;
                    updatePopupWithFinalResult(resultText, result);
                    const tossResultData = { result, revealVotes, timestamp: firebase.database.ServerValue.TIMESTAMP };
                    const updates = { [`coinTosses/${currentUserId}`]: tossResultData, 'activeToss': null };
                    gameStateRef.update(updates).catch(error => { gameStateRef.child('activeToss').set(null); }).finally(() => activeTossTimeoutId = null);
                }, WRITE_RESULT_DELAY);
            }
        } else if (!activeToss && previousActiveToss) {
             // A toss has just finished.
             const finishedTosserId = previousActiveToss.tossingPlayerId;
             if (isPopupVisible && lastDisplayedTosserId === finishedTosserId) {
                 const finalTossData = coinTosses[finishedTosserId];
                 if (finalTossData) {
                     updatePopupWithFinalResult(`Result: ${finalTossData.result}!`, finalTossData.result);
                 } else {
                     popupStatusElement.textContent = "Finished."; 
                 }
             }
        } else if (!activeToss && !previousActiveToss && isPopupVisible && !popupCloseTimerId) { 
            // Cleanup in case the popup gets stuck.
            hideCoinTossPopup();
            if (activeTossTimeoutId) { clearTimeout(activeTossTimeoutId); activeTossTimeoutId = null; }
        }

        // --- Pause Game Logic ---
        // Pauses the game if not enough players are connected.
        let pauseGame = connectedPlayersCount < MIN_CONNECTED_PLAYERS_TO_PROCEED && currentPhase !== 'waiting_start';
        pauseMessageElement.style.display = pauseGame ? 'block' : 'none';
        if (pauseGame) pauseMessageElement.textContent = `Game paused (${connectedPlayersCount}/${MIN_CONNECTED_PLAYERS_TO_PROCEED} players). Waiting...`;
    
        // --- LEADER-ONLY LOGIC: State Transitions ---
        // The leader is responsible for advancing the game state.
        if (isLeader && !pauseGame && !localGameState.activeToss) {
            if (currentPhase === 'waiting_start' && connectedPlayersCount >= MIN_CONNECTED_PLAYERS_TO_PROCEED) {
                startNewRound(); return;
            }
            if (currentPhase === 'voting' && Object.keys(localGameState.votes || {}).filter(id => localPlayersData[id]?.isConnected).length >= connectedPlayersCount) {
                calculateResultsAndTransition(); return;
            }
            if (currentPhase === 'confession_selection' && localGameState.confessionData?.targetId) {
                gameStateRef.child('phase').set('confession_question'); 
                return;
            }
            if (currentPhase === 'confession_question') {
                const {judgments = {}, targetId, chooserId} = localGameState.confessionData || {};
                if(targetId) { 
                    const connectedJudgesCount = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected && id !== targetId).length;
                    if (Object.keys(judgments).length >= connectedJudgesCount) {
                        calculateConfessionVerdict(); return;
                    }
                }
            }
            if ((currentPhase === 'results' || currentPhase === 'confession_result') && Object.keys(localGameState.readyForNextRound || {}).filter(id => localPlayersData[id]?.isConnected).length >= connectedPlayersCount) {
                startNewRound(); return;
            }
        }  
        
        const phase = localGameState.phase || 'waiting_start';
        const isConfession = (phase === 'confession_selection' || phase === 'confession_question' || phase === 'confession_result');
        setConfessionMode(isConfession);
        if (!pauseGame) {
            if (isPopupVisible && currentPhase === 'results') {
                showPhase('results'); 
                renderResultsPhase(); 
            } else {
                 switch (currentPhase) {
                    case 'voting': showPhase('voting'); renderVotingPhase(); break;
                    case 'results': showPhase('results'); renderResultsPhase(); break;
                    case 'confession_selection': showPhase('confession-selection'); renderConfessionSelection(); break;
                    case 'confession_question': showPhase('confession-question'); renderConfessionQuestion(); break;
                    case 'confession_result': showPhase('confession-result'); renderConfessionResultPhase(); break;
                    case 'waiting_start':
                        showPhase('waiting');
                        waitingMessage.textContent = connectedPlayersCount >= MIN_CONNECTED_PLAYERS_TO_PROCEED
                            ? "Preparing..." : `Waiting... (${connectedPlayersCount}/${MIN_CONNECTED_PLAYERS_TO_PROCEED})`;
                        break;
                    default: showPhase('waiting'); waitingMessage.textContent = "Loading..."; break;
                 }
            }
        } else {
             if (currentPhase === 'results') renderResultsPhase();
             else if (currentPhase === 'voting') renderVotingPhase();
        }
    }
    
   // --- Game Logic Functions (Leader-Only) ---

    /**
     * (Leader) Starts a new standard voting round.
     */
    function startNewRound() {
        if (!isLeader) return;

        // Log the results of the previous round to history.
        const completedRoundData = { ...localGameState };
        const updates = {}; 

        if ((localGameState.round || 0) > 0) {
            const roundHistoryUpdate = HistoryLogger.prepareRoundLog(completedRoundData);
            if (roundHistoryUpdate) {
                Object.assign(updates, roundHistoryUpdate);
            }
        } else if (!localFullGameData.history) {  // Log summary only for the first round
            const summaryUpdate = HistoryLogger.prepareSummaryLog(localFullGameData, localPlayersData);
            if (summaryUpdate) {
                Object.assign(updates, summaryUpdate);
            }
        }

        // Check if it's time for a confession round.
        let finalRoundsUntilConfession = localGameState.roundsUntilConfession;
        if (confessionModeEnabled) {
            let currentCountdown = localGameState.roundsUntilConfession;
            if (currentCountdown === undefined || currentCountdown === null || currentCountdown < 0) {
                currentCountdown = Math.floor(Math.random() * 3) + 2; // Randomly 2, 3, or 4
                console.log(`Initializing confession countdown to ${currentCountdown} rounds.`);
            }
            currentCountdown--;
            console.log(`Rounds until confession: ${currentCountdown}`);
            if (currentCountdown <= 0) {
                startConfessionPhase(); // Transition to confession instead of a normal round
                return;
            }
            finalRoundsUntilConfession = currentCountdown;
        }

        // Get a new question.
        const usedIndicesObject = localGameState.usedQuestionIndices || {};
        const usedIndicesSet = new Set(Object.keys(usedIndicesObject).map(Number));
        const newQuestionData = getNewQuestion(usedIndicesSet);
        if (!newQuestionData) {
            console.error("Leader: Failed to get a new question.");
            return;
        }
        usedIndicesSet.add(newQuestionData.index);

        // Prepare the new game state object.
        const newGameState = {
            round: (localGameState.round || 0) + 1,
            phase: 'voting',
            question: newQuestionData.question,
            roundsUntilConfession: confessionModeEnabled ? finalRoundsUntilConfession : null,
            votes: null, 
            results: null, 
            readyForNextRound: null,
            coinTosses: null, 
            activeToss: null,
            usedQuestionIndices: Object.fromEntries(usedIndicesSet.entries()),
            confessionData: null, 
            confessionResult: null
        };
        
        // Write the updates atomically to Firebase.
        updates['currentGame'] = newGameState;
        gameRef.update(updates).catch(error => console.error("Leader: Error starting new round with history logging:", error));
    }
    
    /**
     * (Leader) Calculates vote results and transitions the game to the 'results' phase.
     */
    function calculateResultsAndTransition() { 
        if (!isLeader) return;
        const votes = localGameState.votes || {};
        const voteCounts = {};
        Object.keys(localPlayersData).forEach(playerId => {
            if(localPlayersData[playerId]) voteCounts[playerId] = 0;
        });
        Object.values(votes).forEach(votedForId => {
            if (voteCounts.hasOwnProperty(votedForId)) voteCounts[votedForId]++;
        });
        gameStateRef.update({ phase: 'results', results: voteCounts })
            .catch(error => console.error("Leader: Erreur transition vers results:", error));
    }


    // --- Confession Phase Functions ---
    
    /**
     * (Leader) Initiates the confession phase. This involves selecting a "chooser"
     * based on the previous round's votes and preparing the new game state.
     */
    function startConfessionPhase() {
        if (!isLeader) return;
        
        // --- Select a new, unused confession question ---
        const usedConfessionIndicesObj = localFullGameData.usedConfessionQuestionIndices || {};
        const usedIndicesSet = new Set(Object.keys(usedConfessionIndicesObj).map(Number));
        const newQuestionData = getNewConfessionQuestion(usedIndicesSet);
        
        if (!newQuestionData) {
            console.error("Leader: Failed to get a confession question. Aborting...");
            startNewRound(); // Revert to a normal round as a fallback.
            return;
        }
        usedIndicesSet.add(newQuestionData.index);

        // --- Determine the "chooser" based on who received the most votes last round ---
        const lastResults = localGameState.results || {};
        let maxVotes = -1;
        const tiedPlayers = [];

        Object.entries(lastResults).forEach(([playerId, votes]) => {
            if (localPlayersData[playerId]?.isConnected) { 
                if (votes > maxVotes) {
                    maxVotes = votes;
                    tiedPlayers.length = 0; // Clear the array for a new leader
                    tiedPlayers.push(playerId);
                } else if (votes === maxVotes && maxVotes > 0) { // Only consider ties if there were actual votes.
                    tiedPlayers.push(playerId);
                }
            }
        });

        let chooserId = null;
        if (tiedPlayers.length > 0) {
            // If there's one or more players with the max votes, pick one randomly.
            chooserId = tiedPlayers[Math.floor(Math.random() * tiedPlayers.length)];
        } else {
            // Fallback: if no votes were cast, pick any connected player randomly.
            const connectedPlayerIds = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected);
            if (connectedPlayerIds.length > 0) {
            chooserId = connectedPlayerIds[Math.floor(Math.random() * connectedPlayerIds.length)];
            } else {
                console.warn("Confession phase aborted, no connected players.");
                startNewRound();
                return;
            }
        }
        
        // Reset the countdown for the next confession phase.
        const nextConfessionIn = Math.floor(Math.random() * 3) + 2; // 2, 3, or 4 rounds
        
        const updates = {};

        // 1. Update the `currentGame` fields for the confession phase.
        updates['/currentGame/phase'] = 'confession_selection';
        updates['/currentGame/roundsUntilConfession'] = nextConfessionIn;
        updates['/currentGame/confessionData'] = { 
            chooserId: chooserId, 
            targetId: null,  // The target will be chosen by the chooser.
            question: newQuestionData.question,
            judgments: null 
        };
        // Clear the 'ready' status from the previous round.
        updates['/currentGame/readyForNextRound'] = null; 

        // IMPORTANT: We do not clear `votes`, `results`, `coinTosses`. They are preserved from the last round.

        // 2. Update the list of used confession questions at the root of the lobby.
        updates['/usedConfessionQuestionIndices'] = Object.fromEntries(usedIndicesSet.entries());

        // 3. Send the atomic update to Firebase.
        gameRef.update(updates).catch(error => console.error("Leader: Error starting confession phase:", error));
    }

    /**
     * Renders the UI for the 'confession_selection' phase, showing different content
     * for the "chooser" versus other players.
     */
    function renderConfessionSelection() {
        const { chooserId, question } = localGameState.confessionData || {};
        const chooserPseudo = localPlayersData[chooserId]?.pseudo ||  'Someone';
        const isChooser = currentUserId === chooserId;

        // Populate the question text in its frame.
        confessionQuestionTextSelection.textContent = question || "Loading question...";
        confessionQuestionTextSelection.classList.add('confession-question-hero', 'reveal-in');
        confessionQuestionTextSelection.style.display = 'block';

        if (isChooser) {
             // --- View for the player choosing a target ---
            confessionSelectionSubtitle.innerHTML =  "It's your moment of vengeance... Choose who must answer this question:";
            confessionSelectionInstruction.innerHTML = "ðŸ” Click on a player to designate them as the target.";

            // Populate the target selection buttons.
            playerConfessionTargetOptionsDiv.style.display = 'grid'; 
            playerConfessionTargetOptionsDiv.innerHTML = '';
            const immunePlayers = localFullGameData.immuneToConfession || {};
            Object.entries(localPlayersData).forEach(([playerId, player]) => {
                const btn = document.createElement('button');
                btn.className = 'player-vote-btn';
                btn.dataset.targetId = playerId;
                const img = document.createElement('img');
                img.src = player.avatarSrc;
                img.className = 'player-avatar';
                img.alt = "Avatar";
                btn.appendChild(img);
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name-vote';
                nameSpan.textContent = player.pseudo;
                btn.appendChild(nameSpan);
                btn.addEventListener('click', handleConfessionTargetSelection);
                 // Disable the button for players who are immune.
                if (immunePlayers[playerId]) {
                    btn.disabled = true;
                    const immuneSpan = document.createElement('span');
                    immuneSpan.textContent = 'ðŸ˜‡';
                    immuneSpan.style.fontSize = '1.5em';
                    btn.appendChild(immuneSpan);
                    btn.style.opacity = 0.6;
                }
                playerConfessionTargetOptionsDiv.appendChild(btn);
            });

        } else {
            // --- View for other players waiting for the choice ---
            confessionSelectionSubtitle.innerHTML = `âš ï¸ <strong>${chooserPseudo}</strong> is choosing who must answer the question:`;
            confessionSelectionInstruction.innerHTML = "â³ Please wait... the sentence is about to be passed.";
            playerConfessionTargetOptionsDiv.innerHTML = '';
            playerConfessionTargetOptionsDiv.style.display = 'none';
        }
    }
    
    /**
     * Handles the chooser's click on a player to select them as the confession target.
     * @param {Event} event The click event.
     */
   function handleConfessionTargetSelection(event) {
     // Using .closest() is safer to ensure we get the button element,
     // even if the user clicks on the avatar or name inside it.
      const button = event.target.closest('.player-vote-btn');
      if (!button) {
          console.error("Invalid click, button not found.");
          return;
      }

      const targetId = button.dataset.targetId;
      console.log("targetId: ", targetId);

      // --- VALIDATION AND SAFETY CHECK ---
    // Check that targetId is not null, undefined, or an empty string.
      if (!targetId) {
          console.error("Cannot select target: targetId is invalid.", targetId);
          alert("An error occurred while selecting the player. Please try again.");
          return;
      }

      console.log(`The avenger chose: ${targetId}. Sending signal to leader.`);
      
       // Disable all buttons to prevent double-clicking.
      document.querySelectorAll('#player-confession-target-options .player-vote-btn').forEach(b => b.disabled = true);
      button.classList.add('voted-for');
      gameStateRef.child('confessionData/targetId').set(targetId)
          .catch(err => {
              console.error("Error selecting confession target:", err);
              document.querySelectorAll('#player-confession-target-options .player-vote-btn').forEach(b => b.disabled = false);
              button.classList.remove('voted-for');
              alert("Failed to record your choice. Please try again.");
          });
    }
    
    /**
     * Renders the UI for the 'confession_question' phase, where one player answers
     * and the others judge their response.
     */
    function renderConfessionQuestion() {
        const { targetId, question, judgments = {} } = localGameState.confessionData || {};
        const targetPseudo = localPlayersData[targetId]?.pseudo || 'The target';
        const isTarget = currentUserId === targetId;

        // Populate the question text in its frame.
        confessionQuestionText.textContent = question || "Waiting for the question...";
        confessionQuestionText.classList.add('confession-question-hero', 'reveal-in');
        confessionQuestionText.style.display = 'block';

        if (isTarget) {
            // --- View for the player who must answer ---
            confessionQuestionSubtitle.innerHTML = "It's your turn! You must answer the question:";;
            confessionAnswerPrompt.innerHTML = "ðŸ“¢ Answer out loud for everyone to hear.";
            confessionAnswerPrompt.style.display = 'block';
            confessionJudgmentArea.style.display = 'none';
        } else {
             // --- View for the players who are judging ---
            confessionQuestionSubtitle.innerHTML = `ðŸŽ¯ <strong>${targetPseudo}</strong> is answering the question:`;
            confessionJudgmentInstruction.innerHTML = "âœ… Click <strong>CONVINCED</strong> if you believe their answer, âŒ <strong>NOT BUYING IT</strong> if you think they're lying.";
            
            confessionAnswerPrompt.style.display = 'none';
            confessionJudgmentArea.style.display = 'block';

            
            const hasJudged = !!judgments[currentUserId];
            judgmentConvincedBtn.disabled = hasJudged;
            judgmentNotConvincedBtn.disabled = hasJudged;
            judgmentStatus.textContent = hasJudged ? "Your verdict is recorded." : "Awaiting your verdict...";
        }
         // Update the jury meter progress bar.
        const meterFill = document.querySelector('#jury-meter .jury-fill');
        if (meterFill) { 
            const totalEligible = Object.keys(localPlayersData).filter(id => localPlayersData[id]?.isConnected && id !== targetId).length;
            const currentVotes = Object.keys(judgments).length;
            const percentage = (totalEligible > 0) ? (currentVotes / totalEligible) * 100 : 0;
            meterFill.style.width = percentage + '%';
        }

    }

    /**
     * Handles a click on the "Convinced" or "Not Buying It" buttons.
     * @param {string} vote - The verdict ('convinced' or 'not convinced').
     */
    function handleJudgmentClick(vote) {
        const { targetId, chooserId } = localGameState.confessionData || {};
        if (currentUserId === targetId) return;
        gameStateRef.child(`confessionData/judgments/${currentUserId}`).set(vote)
            .catch(err => console.error("Error sending judgment:", err));
    }
    
    /**
     * (Leader) Calculates the final verdict of the confession based on player judgments
     * and transitions the game to the 'confession_result' phase.
     */
   function calculateConfessionVerdict() {
        if (!isLeader) return;
        
        const { judgments, targetId, chooserId, question } = localGameState.confessionData;
        const targetPseudo = localPlayersData[targetId]?.pseudo || 'The victim';
        
        const convincedVotes = Object.values(judgments || {}).filter(v => v === 'convaincu').length;
        const totalVotes = Object.keys(judgments || {}).length;
        const verdict = (totalVotes > 0 && convincedVotes >= totalVotes / 2) ? 'convaincu' : 'pas convaincu';
        
        const confessionResult = {
            playerName: targetPseudo,
            outcome: verdict,
            details: `${convincedVotes} / ${totalVotes} convinced`
        };

        const updates = {};
        let immunePlayers = localFullGameData.immuneToConfession || {};
        if (verdict === 'convaincu') {
            immunePlayers[targetId] = true;
        }

        const connectedPlayerIds = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected);
        const immuneConnectedCount = connectedPlayerIds.filter(id => immunePlayers[id]).length;
        
        if (immuneConnectedCount >= connectedPlayerIds.length) { 
            console.log("All connected players are immune! Resetting the list.");
            updates['/immuneToConfession'] = null; 
        } else if (verdict === 'convaincu') {
            updates[`/immuneToConfession/${targetId}`] = true;
        }
       
        updates['/currentGame/phase'] = 'confession_result'; 
        updates['/currentGame/confessionResult'] = confessionResult; 
        updates['/currentGame/readyForNextRound'] = null;  

        gameRef.update(updates);
    }

    /**
     * Renders the UI for the 'confession_result' phase, showing the verdict.
     */
    function renderConfessionResultPhase() {
      const confessionResult = localGameState.confessionResult;
      if (confessionResult) {
        const outcomeText = confessionResult.outcome === 'convaincu'
          ? `convinced the jury and becomes <strong>immune</strong>! ðŸ˜‡`
          : `did <strong>NOT</strong> convince the jury and remains a target! ðŸ˜ˆ`;

        // 1) Set the main content.
        confessionVerdictDisplay.innerHTML = `
          <p style="font-size: 1.1em;">
            <strong>${confessionResult.playerName}</strong> ${outcomeText}
          </p>
          <p style="font-size: 0.9em; color: var(--clr-primary-green)">
            (${confessionResult.details})
          </p>`;

        // 2) Then add the animated stamp on top.
        showVerdictStamp(confessionResult.outcome);
      } else {
        confessionVerdictDisplay.innerHTML = `<p class="status-message">Waiting for the verdict...</p>`;
      }

      // Update the "Next Round" button and status.
      const readyForNext = localGameState.readyForNextRound || {};
      isReadyForNext = !!readyForNext[currentUserId];
      nextRoundBtnConfession.disabled = isReadyForNext;
      nextRoundBtnConfession.textContent = isReadyForNext ? "Ready!" : "Ready for the next round?";
      const connectedReadyCount = Object.keys(readyForNext).filter(id => localPlayersData[id]?.isConnected).length;
      readyStatusConfession.textContent = `${connectedReadyCount} / ${connectedPlayersCount} players are ready!`;
    }
    
    // --- Startup & Teardown ---
    document.addEventListener('DOMContentLoaded', initializeGame);
    window.addEventListener('beforeunload', () => { console.log("onDisconnect will handle the disconnection."); });
</script>