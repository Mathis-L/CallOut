<script>
    /**
     * @file GamePage.js
     * This file contains the client-side JavaScript logic for the game page of a multiplayer game.
     * It handles Firebase real-time database interactions, game state management, UI updates,
     * player interactions (voting, coin toss), and navigation.
     *
     * Global constants like firebaseConfig, gameId, currentUserId, currentUserPseudo are expected
     * to be defined in the GamePage.html file (e.g., via server-side templating or a script tag).
     */
    
    // --- GLOBAL CONSTANTS (defined in GamePage.html) ---
    // firebaseConfig, gameId, currentUserId, currentUserPseudo
    
    // --- Local Constants ---
    const MIN_CONNECTED_PLAYERS_TO_PROCEED = 2;
    const COIN_TOSS_ANIMATION_DURATION = 1500; // ms (durÃ©e de l'anim CSS)
    const POPUP_CLOSE_DELAY = 1500; // ms (temps APRES anim avant fermeture popup)
    const WRITE_RESULT_DELAY = 1300; // ms (DÃ©lai AVANT fin anim pour Ã©criture DB par lanceur)
    
    // --- Firebase References ---
    let firebaseApp;
    let database;
    let auth;
    let gameRef;
    let playersRef;
    let currentPlayerRef;
    let gameStateRef;
    
    // --- DOM Elements ---
    let playerListElement;
    let gameContent;
    let votingPhaseDiv;
    let resultsPhaseDiv;
    let waitingAreaDiv;
    let currentQuestionElement;
    let playerVoteOptionsDiv;
    let voteStatusElement;
    let resultsDisplayDiv; 
    let nextRoundBtn;
    let readyStatusElement;
    let leaveGameBtn;
    let waitingMessage;
    let pauseMessageElement;
    let coinTossPopup;
    let popupTosserNameElement;
    let popupCoinElement;
    let popupStatusElement;
    let gameErrorPrompt;
    let gameErrorText;
    let gameErrorHomeLink;
    // NOUVEAU : RÃ©fÃ©rences pour les nouvelles phases
    let confessionSelectionPhaseDiv, confessionQuestionPhaseDiv, confessionResultPhaseDiv;
    let playerConfessionTargetOptionsDiv, confessionQuestionTextSelection;
    let confessionAnswerPrompt, confessionQuestionText, confessionJudgmentArea, confessionVerdictDisplay;
    let judgmentConvincedBtn, judgmentNotConvincedBtn, judgmentStatus;
    let nextRoundBtnConfession, readyStatusConfession;
    let confessionSelectionSubtitle, confessionSelectionInstruction;
    let confessionQuestionSubtitle, confessionJudgmentInstruction;  
    let leaveGamePopup, leavePopupTitle, leavePopupLoader, leavePopupMessage, leavePopupActions;
    
    // --- Local State Variables ---
    let localPlayersData = {};
    let localGameState = {};
    let localFullGameData = {}; 
    let isLeader = false;
    let leaderId = null;
    let hasVotedThisRound = false;
    let isReadyForNext = false;
    let gameStatusListener = null;
    let playersListener = null;
    let connectedPlayersCount = 0;
    let isPopupVisible = false;
    let activeTossTimeoutId = null; 
    let popupCloseTimerId = null; 
    let lastDisplayedTosserId = null; 
    let resultsAnimationPlayedForRound = null;
    let confessionModeEnabled = false;
    
    
    // An object to easily access question lists by their name. In "Questions.html"
    const questionSets = {
      gentle: gentleQuestions,
      mix: mixQuestions,
      extreme: extremeQuestions
    };

    const confessionQuestionSets = {
      gentle: gentleConfessionQuestions,
      mix: mixConfessionQuestions,
      extreme: extremeConfessionQuestions
    };
    
    //  Stores the name of the active question set for this game. Default is 'mix', will be overridden by Firebase value. 
    let currentGameQuestionSet = 'mix'; // Default, will be overridden by Firebase value
    


   const HistoryLogger = {
    /**
     * NOUVEAU : PrÃ©pare l'objet summary pour l'historique de la partie.
     * @param {object} fullGameData - L'objet localFullGameData contenant les mÃ©tadonnÃ©es.
     * @param {object} playersData - L'objet localPlayersData avec la liste des joueurs.
     * @returns {object|null} Un objet formatÃ© pour Ãªtre insÃ©rÃ© dans une mise Ã  jour Firebase.
     */
    prepareSummaryLog(fullGameData, playersData) {
        if (!fullGameData || !playersData) return null;

        // On ne garde que les informations essentielles des joueurs pour le rÃ©sumÃ©.
        const initialPlayers = {};
        for (const [id, player] of Object.entries(playersData)) {
            if (player.isConnected) { // Snapshot des joueurs connectÃ©s au dÃ©marrage
                initialPlayers[id] = {
                    pseudo: player.pseudo,
                    avatarSrc: player.avatarSrc
                };
            }
        }

        const summaryLog = {
            gameId: gameId, // Variable globale
            leaderId: fullGameData.leaderId,
            startTime: firebase.database.ServerValue.TIMESTAMP,
            settings: {
                questionSet: fullGameData.selectedQuestionSet || 'mix',
                confessionModeEnabled: !!fullGameData.confessionModeEnabled
            },
            initialPlayers: initialPlayers
        };

        const path = 'history/summary';
        const updatePayload = {};
        updatePayload[path] = summaryLog;
        return updatePayload;
    },

        /**
     * MODIFIÃ‰ : Formate les donnÃ©es d'un round terminÃ©, y compris un Ã©ventuel Ã©vÃ©nement de confession.
     * @param {object} completedRoundData - L'objet localGameState du round qui vient de se terminer.
     * @returns {object|null} Un objet formatÃ© pour Ãªtre insÃ©rÃ© dans une mise Ã  jour Firebase.
     */
    prepareRoundLog(completedRoundData) {
        if (!completedRoundData || typeof completedRoundData.round !== 'number') return null;

        const roundLog = {
            roundNumber: completedRoundData.round,
            question: completedRoundData.question,
            votes: completedRoundData.votes || null,
            results: completedRoundData.results || null,
            coinTosses: completedRoundData.coinTosses || null,
        };

        // NOUVELLE LOGIQUE : Si le round terminÃ© contient les rÃ©sultats d'une confession, on les inclut.
        if (completedRoundData.confessionResult && completedRoundData.confessionData) {
            console.log(`Logging confession event for round ${completedRoundData.round}`);
            roundLog.confessionEvent = {
                chooserId: completedRoundData.confessionData.chooserId,
                targetId: completedRoundData.confessionData.targetId,
                question: completedRoundData.confessionData.question,
                judgments: completedRoundData.confessionData.judgments || null,
                outcome: completedRoundData.confessionResult.outcome,
                targetBecameImmune: completedRoundData.confessionResult.outcome === 'convaincu'
            };
        }

        const path = `history/rounds/${completedRoundData.round}`;
        const updatePayload = {};
        updatePayload[path] = roundLog;
        return updatePayload;
    }

    };


    // === Confession UI helpers ===
    function ensureConfessionAmbient() {
      if (!document.getElementById('confession-ambient')) {
        const ambient = document.createElement('div');
        ambient.id = 'confession-ambient';
        document.body.appendChild(ambient);
      }
    }

    function setConfessionMode(on) {
      ensureConfessionAmbient();
      document.body.classList.toggle('confession-mode', !!on);
    }

    function highlightChooserAndTarget() {
      const chooser = localGameState?.confessionData?.chooserId;
      const target  = localGameState?.confessionData?.targetId;
      document.querySelectorAll('#player-list li').forEach(li => {
        li.classList.remove('is-chooser', 'is-target');
        const uid = li.dataset.userId;
        if (!uid) return;
        if (uid === chooser) li.classList.add('is-chooser');
        if (uid === target)  li.classList.add('is-target');
      });
    }

    function showVerdictStamp(outcome) {
      const box = document.getElementById('confession-verdict-display');
      if (!box) return;
      const old = box.querySelector('.verdict-stamp');
      if (old) old.remove();
      const stamp = document.createElement('div');
      stamp.className = 'verdict-stamp ' + (outcome === 'convaincu' ? 'approved' : 'rejected');
      stamp.textContent = (outcome === 'convaincu') ? 'Convinced' : 'Not Convinced';
      box.insertAdjacentElement('afterbegin', stamp); // <-- important
    }


    // --- Utility Functions ---
    
    function getNewQuestion(usedIndices) {
        const activeQuestions = questionSets[currentGameQuestionSet] || questionSets['mix'];
        if (!activeQuestions || activeQuestions.length === 0) {
            console.error(`Question set '${currentGameQuestionSet}' is empty or not found!`);
            return null;
        }
        if (usedIndices.size >= activeQuestions.length) {
            console.log(`All questions from set '${currentGameQuestionSet}' have been used. Resetting.`);
            usedIndices.clear(); 
        }
        let newIndex;
        let attempts = 0; 
        do {
            newIndex = Math.floor(Math.random() * activeQuestions.length);
            attempts++;
        } while (usedIndices.has(newIndex) && attempts < activeQuestions.length * 2);

        if (usedIndices.has(newIndex)) {
            console.error("Failed to find an unused question index.");
            return null; 
        }
        return { question: activeQuestions[newIndex], index: newIndex };
    }

    function getNewConfessionQuestion(usedIndices) {
        const activeConfessionQuestions = confessionQuestionSets[currentGameQuestionSet] || confessionQuestionSets['mix'];
        if (!activeConfessionQuestions || activeConfessionQuestions.length === 0) return null;
        if (usedIndices.size >= activeConfessionQuestions.length) {
            console.log("Resetting used confession questions.");
            usedIndices.clear();
        }
        let newIndex;
        let attempts = 0;
        do {
            newIndex = Math.floor(Math.random() * activeConfessionQuestions.length);
            attempts++;
        } while (usedIndices.has(newIndex) && attempts < activeConfessionQuestions.length * 2);

        if (usedIndices.has(newIndex)) {
            console.error("Failed to find an unused confession question.");
            return null;
        }
        return { question: activeConfessionQuestions[newIndex], index: newIndex };
    }
    
    function getWebAppUrl() {
        return new Promise((resolve, reject) => {
            if (typeof google !== 'undefined' && google.script && google.script.run) {
                google.script.run.withSuccessHandler(resolve).withFailureHandler(reject).getScriptUrl();
            } else {
                console.warn("Contexte GAS non disponible, utilisation de l'origine.");
                resolve(window.location.origin + window.location.pathname);
            }
        });
    }
    
    // --- FIREBASE LISTENERS & ON_DISCONNECT MANAGEMENT ---
    
     function cleanupListenersAndDisconnect() {
        console.log("Cleanup: Annulation des listeners et de onDisconnect...");
        if (gameRef && gameStatusListener) gameRef.off('value', gameStatusListener);
        if (playersRef && playersListener) playersRef.off('value', playersListener);
        gameStatusListener = null;
        playersListener = null;
        if (activeTossTimeoutId) clearTimeout(activeTossTimeoutId);
        if (popupCloseTimerId) clearTimeout(popupCloseTimerId);
        activeTossTimeoutId = null;
        popupCloseTimerId = null;
        console.log("Timeouts nettoyÃ©s.");
        if (currentPlayerRef) {
            currentPlayerRef.onDisconnect().cancel().catch(err => console.warn("Erreur cancel onDisconnect:", err));
        }
    }
    
    function attachFirebaseListeners() {
        console.log("Attachement des listeners Firebase...");
        if (!gameRef || !playersRef) {
            console.error("Refs Firebase non valides.");
            return;
        }
    
        gameStatusListener = gameRef.on('value', async (snapshot) => {
            console.log("Listener gameRef: DonnÃ©es reÃ§ues.");
            if (!snapshot.exists()) {
                if (gameStatusListener) {
                    console.log("Partie terminÃ©e (ref inexistante).");
                    alert(`Game ${gameId} is over!`);
                    cleanupListenersAndDisconnect();
                    getWebAppUrl().then(baseUrl => window.top.location.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Game ${gameId} is over.`)}`).catch(() => window.top.location.href = window.location.origin);
                }
                return;
            }
    
            const gameData = snapshot.val();

            if (gameData.status === 'finished' && localGameState.phase !== 'finished') {
                console.log("Game status is 'finished'. Displaying end-game popup.");
                cleanupListenersAndDisconnect();

                // Afficher le popup de fin de partie
                leavePopupTitle.textContent = "Game Over!";
                leavePopupMessage.textContent = "The game has been ended by the host. You can view the final results.";
                leavePopupLoader.style.display = 'none';
                leavePopupActions.innerHTML = '';
                leaveGamePopup.classList.add('visible');

                try {
                    const baseUrl = await getWebAppUrl();
                    const resultsLink = document.createElement('a');
                    resultsLink.href = `${baseUrl}?page=results&gameId=${gameId}`;
                    resultsLink.textContent = "View Final Results";
                    resultsLink.className = "button-like-link";
                    resultsLink.style.backgroundColor = 'var(--clr-primary-green)';
                    resultsLink.onclick = (e) => { e.preventDefault(); window.top.location.href = resultsLink.href; };
                    
                    leavePopupActions.appendChild(resultsLink);
                    leavePopupActions.style.display = 'flex';
                    leavePopupActions.style.flexDirection = 'column';

                } catch(e) {
                    leavePopupMessage.textContent += " Could not generate results link.";
                }
                
                // On met Ã  jour l'Ã©tat local pour ne pas rÃ©afficher le popup en boucle
                localGameState.phase = 'finished'; 
                return; // On arrÃªte le traitement normal car la partie est finie
            }

            localFullGameData = gameData;
            const previousGameState = {...localGameState}; 
            localGameState = gameData.currentGame || {};
            leaderId = gameData.leaderId;
            isLeader = (currentUserId === leaderId);
            currentGameQuestionSet = gameData.selectedQuestionSet || 'mix';
            console.log(`Phase=${localGameState.phase}, Leader=${leaderId}, ActiveToss?`, !!localGameState.activeToss);
            updateGameUIAndState(previousGameState); 
        }, (error) => {
            console.error("Erreur listener gameRef:", error);
            alert("Game server connection error!");
        });
    
        playersListener = playersRef.on('value', (snapshot) => {
            console.log("Listener playersRef: DonnÃ©es reÃ§ues.");
            localPlayersData = snapshot.exists() ? snapshot.val() : {};
            if (!localPlayersData[currentUserId] && playersListener) {
                 console.log("Joueur actuel retirÃ©.");
                 alert("Youâ€™ve been removed from the game!");
                 cleanupListenersAndDisconnect();
                 getWebAppUrl().then(baseUrl => window.top.location.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Youâ€™ve been removed from ${gameId}! See ya!`)}`).catch(() => window.top.location.href = window.location.origin);
                 return;
            }
            updateGameUIAndState(); 
        }, (error) => {
            console.error("Erreur listener playersRef:", error);
            alert("Player list connection failed! ");
        });
    }
    
    
    // --- UI Functions ---
    
     function updatePlayerListUI() {
        if (!playerListElement) return;
        playerListElement.innerHTML = '';
        if (!localPlayersData || Object.keys(localPlayersData).length === 0) {
            playerListElement.innerHTML = '<li class="loading">No players... yet!</li>';
            return;
        }
        const phase = localGameState?.phase;
        const votes = localGameState?.votes || {};
        const readyForNext = localGameState?.readyForNextRound || {};
        const judgments = localGameState.confessionData?.judgments || {};

        Object.entries(localPlayersData).forEach(([id, player]) => {
            const li = document.createElement('li');
            li.dataset.userId = id;
            const isConnected = player.isConnected === true;
             if (player.avatarSrc) {
                 const img = document.createElement('img');
                 img.src = player.avatarSrc;
                 img.alt = "Avatar";
                 img.classList.add('player-avatar');
                 li.appendChild(img);
             }
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('player-name-list');
            nameSpan.textContent = player.pseudo || 'Anonyme';
            li.appendChild(nameSpan); 
            if (!isConnected) li.classList.add('disconnected');
            if (id === leaderId) li.classList.add('is-leader');
            if (id === currentUserId) li.classList.add('is-self');
    
            const statusIndicator = document.createElement('span');
            statusIndicator.className = 'status-indicator';
            if (isConnected) {
                let isPlayerReadyOrVoted = false;
                if (phase === 'voting' && votes[id]) isPlayerReadyOrVoted = true;
                else if ((phase === 'results' || phase === 'confession_result') && readyForNext[id]) isPlayerReadyOrVoted = true;
                else if (phase === 'confession_question' && judgments[id]) isPlayerReadyOrVoted = true;
                if (isPlayerReadyOrVoted) statusIndicator.classList.add('ready');
            }
            li.appendChild(statusIndicator);
            playerListElement.appendChild(li);
        });
        if (leaveGameBtn) leaveGameBtn.textContent = isLeader ? "Finish Game" : "Bail Out!";
        highlightChooserAndTarget();
    }
    
    function showPhase(phaseToShow) {
        console.log("Affichage de la phase:", phaseToShow);
         const phases = [
            votingPhaseDiv, resultsPhaseDiv, waitingAreaDiv, 
            confessionSelectionPhaseDiv, confessionQuestionPhaseDiv, confessionResultPhaseDiv
        ];
        phases.forEach(phaseDiv => {
            if (phaseDiv) {
                const isTargetPhase = phaseDiv.id === `${phaseToShow}-phase` || phaseDiv.id === `${phaseToShow}-area`;
                phaseDiv.classList.toggle('active', isTargetPhase);
            }
        });
        pauseMessageElement.style.display = localGameState.isPaused ? 'block' : 'none'; 
        const elementToShow = document.getElementById(`${phaseToShow}-phase`) || document.getElementById(`${phaseToShow}-area`);
        if (!elementToShow) {
            console.warn("Phase inconnue:", phaseToShow);
             if (waitingAreaDiv) waitingAreaDiv.classList.add('active');
             if (waitingMessage) waitingMessage.textContent = "Unknown status...";
        }
    }
    
    function renderVotingPhase() {
        currentQuestionElement.textContent = localGameState.question || "Loading...";
        playerVoteOptionsDiv.innerHTML = '';
        hasVotedThisRound = !!(localGameState.votes && localGameState.votes[currentUserId]);
        const myVoteTargetId = localGameState.votes?.[currentUserId];
        Object.entries(localPlayersData).forEach(([id, player]) => {
             if (id === currentUserId) return;
            const isTargetConnected = player.isConnected === true;
            const btn = document.createElement('button');
            btn.classList.add('player-vote-btn');
            btn.dataset.targetUserId = id;
            if (player.avatarSrc) {
                const img = document.createElement('img');
                img.src = player.avatarSrc;
                img.alt = "Avatar";
                img.classList.add('player-avatar');
                btn.appendChild(img);
            }
            const nameSpan = document.createElement('span'); 
            nameSpan.classList.add('player-name-vote');
            nameSpan.textContent = player.pseudo || 'Anonyme';
            if (!isTargetConnected) {
               btn.classList.add('target-disconnected');
               nameSpan.textContent += " (Offline)"; 
            }
            btn.appendChild(nameSpan); 
            btn.disabled = hasVotedThisRound;
            if (hasVotedThisRound && myVoteTargetId === id) { btn.classList.add('voted-for'); }
            btn.addEventListener('click', handleVoteClick);
            playerVoteOptionsDiv.appendChild(btn);
        });
        const votes = localGameState.votes || {};
        const connectedVotesCount = Object.keys(votes).filter(id => localPlayersData[id]?.isConnected).length;
        if (hasVotedThisRound) {
            const votedForPseudo = localPlayersData[myVoteTargetId]?.pseudo || 'a player';
            const remainingVotes = Math.max(0, connectedPlayersCount - connectedVotesCount);
            voteStatusElement.textContent = `Youâ€™ve voted for ${votedForPseudo}! Waiting on ${remainingVotes} more vote(s)...`;
        } else {
            voteStatusElement.textContent = `Vote time! ${connectedVotesCount}/${connectedPlayersCount} players voted!`;
        }
    }
    
    function renderResultsPhase() {
        resultsDisplayDiv.innerHTML = '';
        const results = localGameState.results || {};
        const readyForNext = localGameState.readyForNextRound || {};
        const coinTossesData = localGameState.coinTosses || {};
        const activeToss = localGameState.activeToss;
        isReadyForNext = !!readyForNext[currentUserId];
        const currentRound = localGameState.round; 
        const playAnimation = resultsAnimationPlayedForRound !== currentRound;
        if (playAnimation) {
            console.log(`PremiÃ¨re apparition des rÃ©sultats pour la manche ${currentRound}. Animation !`);
            resultsAnimationPlayedForRound = currentRound; 
        }
        if (Object.keys(results).length === 0) {
            resultsDisplayDiv.innerHTML = '<p>No votes recorded...</p>';
            if (playAnimation) resultsAnimationPlayedForRound = currentRound;
        } else {
            const sortedResults = Object.entries(results).sort(([, a], [, b]) => b - a);
            let maxVotes = 0;
            sortedResults.forEach(([, count]) => { if (count > maxVotes) maxVotes = count; });
            const voteScale = maxVotes > 0 ? maxVotes : 1;
            const animationDelayIncrement = 1000; 
            sortedResults.forEach(([playerId, count], index) => {
                const player = localPlayersData[playerId];
                if (!player) return;
                const resultItemDiv = document.createElement('div');
                resultItemDiv.className = 'result-item';
                resultItemDiv.dataset.playerId = playerId;
                if (!player.isConnected) resultItemDiv.classList.add('disconnected-result');
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'result-score';
                const scorePlayer = document.createElement('div');
                scorePlayer.className = 'result-score-player';
                if (player.avatarSrc) {
                  const img = document.createElement('img');
                  img.src = player.avatarSrc;
                  img.alt = "Avatar";
                  img.classList.add('player-avatar');
                  scorePlayer.appendChild(img); 
                }
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name-result';
                nameSpan.textContent = player.pseudo || 'Inconnu';
                if (!player.isConnected) nameSpan.textContent += " (DÃ©co)";
                const countStrong = document.createElement('strong');
                countStrong.classList.add('player-vote-count');
                countStrong.textContent = `${count} vote${count > 1 ? 's' : ''}`;
                scorePlayer.appendChild(nameSpan);
                scoreDiv.appendChild(scorePlayer);
                scoreDiv.appendChild(countStrong);
                resultItemDiv.appendChild(scoreDiv);
                const voteBarContainer = document.createElement('div');
                voteBarContainer.className = 'vote-bar-container';
                const voteBarFill = document.createElement('div');
                voteBarFill.className = 'vote-bar-fill';
                const barWidthPercentage = (count / voteScale) * 100;
                voteBarContainer.appendChild(voteBarFill);
                resultItemDiv.appendChild(voteBarContainer);
                if (count > 0) {
                    const tossSectionDiv = document.createElement('div'); tossSectionDiv.className = 'coin-toss-section';
                    const statusSpan = document.createElement('span'); statusSpan.className = 'coin-toss-status';
                    const tossData = coinTossesData[playerId];
                    let canToss = (currentUserId === playerId && !tossData && !activeToss);
                    if (tossData) {
                        statusSpan.textContent = `Results : ${tossData.result === 'HEADS' ? 'HEADS !' : 'TAILS !'}`;
                    } else if (activeToss) {
                         statusSpan.textContent = activeToss.tossingPlayerId === playerId ? "Tossing..." : `Hold tight! ${activeToss.tossingPlayerPseudo} is about to toss... `;
                    } else {
                        statusSpan.textContent = (currentUserId === playerId) ? "Ready to toss?" : "Waiting for the toss...";
                    }
                    tossSectionDiv.appendChild(statusSpan);
                    if (canToss) {
                        const tossBtn = document.createElement('button'); tossBtn.className = 'toss-trigger-button'; tossBtn.dataset.targetPlayerId = playerId; tossBtn.textContent = 'Toss the coin!';
                        tossSectionDiv.appendChild(tossBtn);
                    }
                    resultItemDiv.appendChild(tossSectionDiv);
                    if (tossData && tossData.revealVotes) {
                        const revealedDiv = document.createElement('div'); revealedDiv.className = 'revealed-votes';
                        const ul = document.createElement('ul'); const votes = localGameState.votes || {}; let revealedCount = 0;
                        Object.entries(votes).forEach(([voterId, votedId]) => {
                            if (votedId === playerId) {
                                const voter = localPlayersData[voterId]; const voterName = voter?.pseudo || 'Player left';
                                const li = document.createElement('li'); li.innerHTML = `Voter: <strong>${voterName}</strong> ${!voter?.isConnected ? '(Offline)' : ''}`;
                                ul.appendChild(li); revealedCount++;
                            }
                        });
                        revealedDiv.innerHTML = `<h6>Votes revealed:</h6>`;
                        if (revealedCount > 0) revealedDiv.appendChild(ul); else revealedDiv.innerHTML += `<i>Nobody voted for ${player.pseudo}!</i>`;
                        revealedDiv.style.display = 'block'; resultItemDiv.appendChild(revealedDiv);
                    } else if (tossData && !tossData.revealVotes) {
                        const revealedDiv = document.createElement('div'); revealedDiv.className = 'revealed-votes';
                        revealedDiv.innerHTML = `<h6>Results :</h6><i>Votes remain secret (Tails)! ðŸ¤«</i>`;
                        revealedDiv.style.display = 'block'; resultItemDiv.appendChild(revealedDiv);
                    }
                }
                resultsDisplayDiv.appendChild(resultItemDiv);
                if (playAnimation) {
                    const currentDelay = index * animationDelayIncrement;
                    setTimeout(() => {
                        resultItemDiv.classList.add('appear'); 
                        setTimeout(() => { voteBarFill.style.width = `${barWidthPercentage}%`; }, 100);
                    }, currentDelay);
                } else {
                    resultItemDiv.style.opacity = 1;
                    resultItemDiv.style.transform = 'translateY(0)';
                    voteBarFill.style.width = `${barWidthPercentage}%`;
                }
            });
        }
        nextRoundBtn.disabled = isReadyForNext;
        nextRoundBtn.textContent = isReadyForNext ? "Ready!" : "Ready for the next round!";
        nextRoundBtn.classList.toggle('ready', isReadyForNext);
        const connectedReadyCount = Object.keys(readyForNext).filter(id => localPlayersData[id]?.isConnected).length;
        readyStatusElement.textContent = `${connectedReadyCount} / ${connectedPlayersCount} players are ready !`;
    }
    
    // --- Coin Toss Popup Functions ---
    
    function showCoinTossPopup(tosserId, tosserPseudo) {
        if (!coinTossPopup || isPopupVisible) {
            if (isPopupVisible && lastDisplayedTosserId !== tosserId) {
                 popupTosserNameElement.innerHTML = `<strong>${tosserPseudo}</strong> toss the coin... `;
                 lastDisplayedTosserId = tosserId;
            }
            return;
        }
        console.log(`Affichage popup pour ${tosserPseudo} (ID: ${tosserId})`);
        lastDisplayedTosserId = tosserId; 
        popupTosserNameElement.innerHTML = ''; 
        const tosserData = localPlayersData[tosserId];
        if (tosserData && tosserData.avatarSrc) {
            const img = document.createElement('img');
            img.src = tosserData.avatarSrc;
            img.alt = "Avatar";
            img.classList.add('player-avatar-popup'); 
            popupTosserNameElement.appendChild(img);
        }
        const nameText = document.createElement('span'); 
        nameText.innerHTML = `<strong>${tosserPseudo}</strong> toss the coin...`;
        popupTosserNameElement.appendChild(nameText);
        popupStatusElement.textContent = "Tossing...";
        popupCoinElement.style.transform = 'rotateX(45deg)'; 
        popupCoinElement.style.display = 'block';
        popupCoinElement.classList.remove('animate');
        void popupCoinElement.offsetWidth; 
        popupCoinElement.classList.add('animate');
        coinTossPopup.classList.add('visible');
        isPopupVisible = true;
        clearTimeout(popupCloseTimerId); 
        popupCloseTimerId = setTimeout(hideCoinTossPopup, COIN_TOSS_ANIMATION_DURATION + POPUP_CLOSE_DELAY);
    }
    
    function hideCoinTossPopup() {
        if (!isPopupVisible) return;
        console.log("Fermeture popup lancer.");
        clearTimeout(popupCloseTimerId); 
        popupCloseTimerId = null;
        lastDisplayedTosserId = null; 
        popupCoinElement.classList.remove('animate');
        coinTossPopup.classList.remove('visible');
        setTimeout(() => {
            if (!coinTossPopup.classList.contains('visible')) {
                 popupCoinElement.style.display = 'none';
            }
        }, 300);
        isPopupVisible = false;
    }
    
    function updatePopupWithFinalResult(resultText, result) {
        if (isPopupVisible) {
            console.log(`Popup: Affichage rÃ©sultat final: ${resultText}`);
            popupStatusElement.textContent = resultText;
            popupCoinElement.classList.remove('animate'); 
            const finalRotation = result === 'HEADS' ? 'rotateX(45deg)' : 'rotateX(225deg)';
            popupCoinElement.style.transform = finalRotation;
        } else {
            console.warn("Tentative d'afficher rÃ©sultat final dans popup non visible.");
        }
    }
    
    // --- User Event Handlers ---
    
   async function leaveGameVoluntarily() { 
    const iAmLeader = (currentUserId === leaderId);
    leaveGameBtn.disabled = true;

    // AFFICHER LE POPUP DE CONFIRMATION
    leavePopupLoader.style.display = 'none';
    leavePopupActions.style.display = 'flex';
    leavePopupActions.style.flexDirection = 'column';
    leavePopupActions.innerHTML = ''; // Toujours vider les actions prÃ©cÃ©dentes
    leaveGamePopup.classList.add('visible');

    // DÃ‰FINIR LE BOUTON D'ANNULATION COMMUN
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = "Cancel";
    cancelBtn.style.backgroundColor = 'var(--clr-disabled-bg)';
    cancelBtn.style.color = 'var(--clr-text-dark)';
    cancelBtn.style.marginTop = '10px';
    cancelBtn.onclick = () => {
        leaveGamePopup.classList.remove('visible');
        leaveGameBtn.disabled = false; // RÃ©activer le bouton principal
    };

    if (iAmLeader) {
        // --- Ã‰TAPE DE CONFIRMATION POUR LE LEADER ---
        leavePopupTitle.textContent = "Finish Game?";
        leavePopupMessage.textContent = "Are you sure you want to end the game for everyone?";

        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = "Yes, End It";
        confirmBtn.style.backgroundColor = 'var(--clr-error)';
        
        confirmBtn.onclick = async () => {
            // Afficher un Ã©tat de chargement
            leavePopupMessage.textContent = "Ending the game, please wait...";
            leavePopupActions.style.display = 'none';
            leavePopupLoader.style.display = 'block';

            cleanupListenersAndDisconnect();
            
            try {
                const baseUrl = await getWebAppUrl();
                await gameRef.update({ 
                    status: 'finished',
                    endTime: firebase.database.ServerValue.TIMESTAMP 
                });

                // Afficher le rÃ©sultat final
                leavePopupTitle.textContent = "Game Ended";
                leavePopupMessage.textContent = "The game has been successfully ended. You can now view the final results.";
                leavePopupLoader.style.display = 'none';
                
                const resultsLink = document.createElement('a');
                resultsLink.href = `${baseUrl}?page=results&gameId=${gameId}`;
                resultsLink.textContent = "View Final Results";
                resultsLink.className = "button-like-link";
                resultsLink.style.backgroundColor = 'var(--clr-primary-green)';
                resultsLink.onclick = (e) => { e.preventDefault(); window.top.location.href = resultsLink.href; };

                leavePopupActions.innerHTML = '';
                leavePopupActions.appendChild(resultsLink);
                leavePopupActions.style.display = 'flex';

            } catch (error) {
                console.error("Error ending game:", error);
                leavePopupTitle.textContent = "Error!";
                leavePopupMessage.textContent = `An error occurred: ${error.message}.`;
                leavePopupLoader.style.display = 'none';
            }
        };

        leavePopupActions.appendChild(confirmBtn);
        leavePopupActions.appendChild(cancelBtn);
    
    } else {
        // --- NOUVELLE Ã‰TAPE DE CONFIRMATION POUR LES JOUEURS ---
        leavePopupTitle.textContent = "Leave Game?";
        leavePopupMessage.textContent = "Are you sure you want to bail out? You won't be able to rejoin this game.";

        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = "Yes, I'm Out";
        confirmBtn.style.backgroundColor = 'var(--clr-error)';

        confirmBtn.onclick = async () => {
            // Afficher un Ã©tat de chargement
            leavePopupMessage.textContent = "Processing your request...";
            leavePopupActions.style.display = 'none';
            leavePopupLoader.style.display = 'block';

            cleanupListenersAndDisconnect();
            
            try {
                const baseUrl = await getWebAppUrl();
                if (currentPlayerRef) await currentPlayerRef.remove();
                
                leavePopupTitle.textContent = "You've Left!";
                leavePopupMessage.textContent = "You have successfully left the game.";
                leavePopupLoader.style.display = 'none';

                const homeLink = document.createElement('a');
                homeLink.href = `${baseUrl}?page=home&message=${encodeURIComponent(`Youâ€™ve left game ${gameId}!`)}`;
                homeLink.textContent = "Return to Home";
                homeLink.className = "button-like-link";
                homeLink.style.backgroundColor = 'var(--clr-primary-green)';
                homeLink.onclick = (e) => { e.preventDefault(); window.top.location.href = homeLink.href; };
                
                leavePopupActions.innerHTML = '';
                leavePopupActions.appendChild(homeLink);
                leavePopupActions.style.display = 'flex';

            } catch (error) {
                console.error("Error leaving the game:", error);
                leavePopupTitle.textContent = "Error!";
                leavePopupMessage.textContent = `An error occurred: ${error.message}. Please try returning home.`;
                leavePopupLoader.style.display = 'none';

                const homeLink = document.createElement('a');
                homeLink.href = window.location.origin;
                homeLink.textContent = "Return to Home";
                homeLink.className = "button-like-link";
                homeLink.style.backgroundColor = 'var(--clr-error)';
                homeLink.onclick = (e) => { e.preventDefault(); window.top.location.href = homeLink.href; };

                leavePopupActions.innerHTML = '';
                leavePopupActions.appendChild(homeLink);
                leavePopupActions.style.display = 'flex';
            }
        };
        
        leavePopupActions.appendChild(confirmBtn);
        leavePopupActions.appendChild(cancelBtn);
    }
}
    
    function handleVoteClick(event) { 
        const clickedButton = event.target.closest('.player-vote-btn'); 
        if (!clickedButton || clickedButton.disabled || hasVotedThisRound) return;
        const targetUserId = clickedButton.dataset.targetUserId;
        if (!targetUserId) return;
        document.querySelectorAll('.player-vote-btn').forEach(btn => btn.disabled = true);
        clickedButton.classList.add('voted-for');
        gameStateRef.child('votes').child(currentUserId).set(targetUserId)
            .catch(error => {
                console.error("Firebase vote write FAILED:", error);
                alert("Oops! Error recording your vote! Please try again!");
                 document.querySelectorAll('.player-vote-btn').forEach(btn => {
                     if (!(localGameState.votes && localGameState.votes[currentUserId])) btn.disabled = false;
                 });
                 clickedButton.classList.remove('voted-for'); 
            });
    }
    
    function handleNextRoundClick() { 
        if (isReadyForNext) return;
        const isConfessionResultPhase = localGameState.phase === 'confession_result';
        const buttonToUpdate = isConfessionResultPhase ? nextRoundBtnConfession : nextRoundBtn;
        buttonToUpdate.disabled = true;
        buttonToUpdate.textContent = "Ready !";
        buttonToUpdate.classList.add('ready');
        gameStateRef.child('readyForNextRound').child(currentUserId).set(true)
            .catch(error => {
                console.error("Erreur envoi 'PrÃªt':", error);
                alert("Error recording 'Ready' status.");
                buttonToUpdate.disabled = false;
                buttonToUpdate.textContent = "Ready for the next round";
                buttonToUpdate.classList.remove('ready');
            });
    }
    
    function handleCoinTossTriggerClick(event) { 
         if (!event.target.matches('.toss-trigger-button')) return; 
         const button = event.target;
         const targetPlayerId = button.dataset.targetPlayerId;
         if (currentUserId !== targetPlayerId || (localGameState.coinTosses && localGameState.coinTosses[targetPlayerId]) || localGameState.activeToss) {
              if(localGameState.activeToss) alert(`Wait for ${localGameState.activeToss.tossingPlayerPseudo}'s toss to finish...`);
              return;
         }
         button.disabled = true;
         button.textContent = 'Tossing...';
         const tossInitiationData = {
             tossingPlayerId: currentUserId,
             tossingPlayerPseudo: currentUserPseudo, 
             startTime: firebase.database.ServerValue.TIMESTAMP
         };
         gameStateRef.child('activeToss').set(tossInitiationData)
             .catch(error => {
                 console.error("Erreur lors du dÃ©clenchement du lancer:", error);
                 alert("Error during coin toss.");
                 if(button) { button.disabled = false; button.textContent = 'Toss the coin!'; }
             });
    }

    function showGameErrorAndRedirect(errorMessage) {
        console.error("Displaying critical game error:", errorMessage);
        const playerListArea = document.getElementById('player-list-area');
        const gameCard = document.querySelector('.game-card');
        if (playerListArea) playerListArea.style.display = 'none';
        if (gameCard) gameCard.style.display = 'none';
        gameErrorText.textContent = `Oops! ${errorMessage}`;
        gameErrorPrompt.style.display = 'block';
        getWebAppUrl().then(baseUrl => {
            gameErrorHomeLink.href = `${baseUrl}?page=home&error=${encodeURIComponent("Disconnected from game.")}`;
        }).catch(() => { gameErrorHomeLink.href = window.location.origin; });
    }
    
    // --- Main Game Logic ---
    
    function initializeGame() {
         playerListElement = document.getElementById('player-list');
         gameContent = document.getElementById('game-content');
         votingPhaseDiv = document.getElementById('voting-phase');
         resultsPhaseDiv = document.getElementById('results-phase');
         resultsDisplayDiv = document.getElementById('results-display');
         waitingAreaDiv = document.getElementById('waiting-area');
         currentQuestionElement = document.getElementById('current-question');
         playerVoteOptionsDiv = document.getElementById('player-vote-options');
         voteStatusElement = document.getElementById('vote-status');
         nextRoundBtn = document.getElementById('next-round-btn');
         readyStatusElement = document.getElementById('ready-status');
         leaveGameBtn = document.getElementById('leaveGameBtn');
         waitingMessage = document.getElementById('waiting-message');
         pauseMessageElement = document.getElementById('pause-message');
         coinTossPopup = document.getElementById('coin-toss-popup');
         popupTosserNameElement = document.getElementById('popup-tosser-name');
         popupCoinElement = document.getElementById('popup-coin');
         popupStatusElement = document.querySelector('#coin-toss-popup .popup-status'); 
         gameErrorPrompt = document.getElementById('game-error-prompt');
         gameErrorText = document.getElementById('game-error-text');
         gameErrorHomeLink = document.getElementById('game-error-home-link');
        confessionSelectionPhaseDiv = document.getElementById('confession-selection-phase');
        confessionQuestionPhaseDiv = document.getElementById('confession-question-phase');
        confessionResultPhaseDiv = document.getElementById('confession-result-phase');
        playerConfessionTargetOptionsDiv = document.getElementById('player-confession-target-options');
        confessionQuestionTextSelection = document.getElementById('confession-question-text-selection');
        confessionAnswerPrompt = document.getElementById('confession-answer-prompt');
        confessionJudgmentArea = document.getElementById('confession-judgment-area');
        confessionVerdictDisplay = document.getElementById('confession-verdict-display');
        judgmentConvincedBtn = document.getElementById('judgment-convinced-btn');
        judgmentNotConvincedBtn = document.getElementById('judgment-not-convinced-btn');
        judgmentStatus = document.getElementById('judgment-status');
        nextRoundBtnConfession = document.getElementById('next-round-btn-confession');
        readyStatusConfession = document.getElementById('ready-status-confession');
        confessionQuestionText = document.getElementById('confession-question-text');
        confessionSelectionSubtitle = document.getElementById('confession-selection-subtitle');
        confessionSelectionInstruction = document.getElementById('confession-selection-instruction');
        confessionQuestionSubtitle = document.getElementById('confession-question-subtitle');
        confessionJudgmentInstruction = document.getElementById('confession-judgment-instruction');
        leaveGamePopup = document.getElementById('leave-game-popup');
    leavePopupTitle = document.getElementById('leave-popup-title');
    leavePopupLoader = document.getElementById('leave-popup-loader');
    leavePopupMessage = document.getElementById('leave-popup-message');
    leavePopupActions = document.getElementById('leave-popup-actions');


          if(!resultsDisplayDiv) {
              alert("Critical error: Game interface failed to load.");
              return;
          }
          showPhase('waiting');
          waitingMessage.textContent = "Connecting to game server...";
          try {
              if (!firebase.apps.length) firebaseApp = firebase.initializeApp(firebaseConfig);
              else firebaseApp = firebase.app();
              database = firebase.database();
              auth = firebase.auth(); 
              gameRef = database.ref(`lobbies/${gameId}`);
              playersRef = database.ref(`lobbies/${gameId}/players`);
              currentPlayerRef = playersRef.child(currentUserId);
              gameStateRef = database.ref(`lobbies/${gameId}/currentGame`);
              auth.onAuthStateChanged(user => {
              if (user) {
                  if (user.uid === currentUserId) {
                      // 1. DÃ©finir le "testament" (onDisconnect) en premier.
                      // Il s'exÃ©cutera si le navigateur est fermÃ© ou si la dÃ©connexion est longue.
                      currentPlayerRef.onDisconnect().update({
                          isConnected: false,
                          disconnectedAt: firebase.database.ServerValue.TIMESTAMP
                      }).catch(error => console.error("Could not set onDisconnect handler:", error));

                      // 2. Ã‰couter l'Ã©tat de la connexion locale du client Firebase.
                      const connectedRef = database.ref('.info/connected');
                      connectedRef.on('value', (snap) => {
                          if (snap.val() === true) {
                              // Si on est connectÃ© (ou qu'on vient de se reconnecter),
                              // on force notre statut Ã  'true' dans la base de donnÃ©es.
                              // C'est cette action qui annule l'effet de onDisconnect lors d'un bref changement de rÃ©seau.
                              console.log("Connection active. Forcing isConnected: true.");
                              currentPlayerRef.update({
                                  isConnected: true,
                                  lastSeen: firebase.database.ServerValue.TIMESTAMP
                              });
                          }
                          // Pas besoin de 'else', car onDisconnect gÃ¨re le passage Ã  'false'.
                      });

                      // 3. Attacher les listeners du jeu
                      attachFirebaseListeners();

                  } else {
                      showGameErrorAndRedirect("Session invalid. Please rejoin from home.");
                  }
              } else {
                  showGameErrorAndRedirect("Authentication expired. Please rejoin from home.");
              }
          });
          } catch (error) {
              showGameErrorAndRedirect(`Initialization failed: ${error.message}`);
          }
        nextRoundBtn.addEventListener('click', handleNextRoundClick);
        nextRoundBtnConfession.addEventListener('click', handleNextRoundClick);
        leaveGameBtn.addEventListener('click', leaveGameVoluntarily);
        resultsDisplayDiv.addEventListener('click', handleCoinTossTriggerClick);
        judgmentConvincedBtn.addEventListener('click', () => handleJudgmentClick('convaincu'));
        judgmentNotConvincedBtn.addEventListener('click', () => handleJudgmentClick('pas convaincu'));
    }
    
    function updateGameUIAndState(previousGameState = {}) {
        if (!localPlayersData) return;
        connectedPlayersCount = Object.values(localPlayersData).filter(p => p.isConnected === true).length;
        updatePlayerListUI(); 
        confessionModeEnabled = !!localFullGameData.confessionModeEnabled;
        const currentPhase = localGameState.phase || 'waiting_start';
        const activeToss = localGameState.activeToss;
        const previousActiveToss = previousGameState.activeToss;
        const coinTosses = localGameState.coinTosses || {};
        if (activeToss && (!previousActiveToss || previousActiveToss.tossingPlayerId !== activeToss.tossingPlayerId)) {
            showCoinTossPopup(activeToss.tossingPlayerId, activeToss.tossingPlayerPseudo || 'A player');
            if (activeToss.tossingPlayerId === currentUserId && !activeTossTimeoutId) {
                activeTossTimeoutId = setTimeout(() => {
                    const result = Math.random() < 0.5 ? 'HEADS' : 'TAILS';
                    const revealVotes = (result === 'HEADS');
                    const resultText = `Result: ${result}!`;
                    updatePopupWithFinalResult(resultText, result);
                    const tossResultData = { result, revealVotes, timestamp: firebase.database.ServerValue.TIMESTAMP };
                    const updates = { [`coinTosses/${currentUserId}`]: tossResultData, 'activeToss': null };
                    gameStateRef.update(updates).catch(error => { gameStateRef.child('activeToss').set(null); }).finally(() => activeTossTimeoutId = null);
                }, WRITE_RESULT_DELAY);
            }
        } else if (!activeToss && previousActiveToss) {
             const finishedTosserId = previousActiveToss.tossingPlayerId;
             if (isPopupVisible && lastDisplayedTosserId === finishedTosserId) {
                 const finalTossData = coinTosses[finishedTosserId];
                 if (finalTossData) {
                     updatePopupWithFinalResult(`Result: ${finalTossData.result}!`, finalTossData.result);
                 } else {
                     popupStatusElement.textContent = "Finished."; 
                 }
             }
        } else if (!activeToss && !previousActiveToss && isPopupVisible && !popupCloseTimerId) { 
            hideCoinTossPopup();
            if (activeTossTimeoutId) { clearTimeout(activeTossTimeoutId); activeTossTimeoutId = null; }
        }

        let pauseGame = connectedPlayersCount < MIN_CONNECTED_PLAYERS_TO_PROCEED && currentPhase !== 'waiting_start';
        pauseMessageElement.style.display = pauseGame ? 'block' : 'none';
        if (pauseGame) pauseMessageElement.textContent = `Game paused (${connectedPlayersCount}/${MIN_CONNECTED_PLAYERS_TO_PROCEED} players). Waiting...`;
    
        if (isLeader && !pauseGame && !localGameState.activeToss) {
            if (currentPhase === 'waiting_start' && connectedPlayersCount >= MIN_CONNECTED_PLAYERS_TO_PROCEED) {
                startNewRound(); return;
            }
            if (currentPhase === 'voting' && Object.keys(localGameState.votes || {}).filter(id => localPlayersData[id]?.isConnected).length >= connectedPlayersCount) {
                calculateResultsAndTransition(); return;
            }
            if (currentPhase === 'confession_selection' && localGameState.confessionData?.targetId) {
                // La question est dÃ©jÃ  assignÃ©e. On passe directement Ã  la phase de questionnement.
                gameStateRef.child('phase').set('confession_question'); 
                return;
            }
            if (currentPhase === 'confession_question') {
                const {judgments = {}, targetId, chooserId} = localGameState.confessionData || {};
                if(targetId) { 
                    const connectedJudgesCount = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected && id !== targetId).length;
                    if (Object.keys(judgments).length >= connectedJudgesCount) {
                        calculateConfessionVerdict(); return;
                    }
                }
            }
            if ((currentPhase === 'results' || currentPhase === 'confession_result') && Object.keys(localGameState.readyForNextRound || {}).filter(id => localPlayersData[id]?.isConnected).length >= connectedPlayersCount) {
                startNewRound(); return;
            }
        }  
        const phase = localGameState.phase || 'waiting_start';
        const isConfession = (phase === 'confession_selection' || phase === 'confession_question' || phase === 'confession_result');
        setConfessionMode(isConfession);
        if (!pauseGame) {
            if (isPopupVisible && currentPhase === 'results') {
                showPhase('results'); 
                renderResultsPhase(); 
            } else {
                 switch (currentPhase) {
                    case 'voting': showPhase('voting'); renderVotingPhase(); break;
                    case 'results': showPhase('results'); renderResultsPhase(); break;
                    case 'confession_selection': showPhase('confession-selection'); renderConfessionSelection(); break;
                    case 'confession_question': showPhase('confession-question'); renderConfessionQuestion(); break;
                    case 'confession_result': showPhase('confession-result'); renderConfessionResultPhase(); break;
                    case 'waiting_start':
                        showPhase('waiting');
                        waitingMessage.textContent = connectedPlayersCount >= MIN_CONNECTED_PLAYERS_TO_PROCEED
                            ? "Preparing..." : `Waiting... (${connectedPlayersCount}/${MIN_CONNECTED_PLAYERS_TO_PROCEED})`;
                        break;
                    default: showPhase('waiting'); waitingMessage.textContent = "Loading..."; break;
                 }
            }
        } else {
             if (currentPhase === 'results') renderResultsPhase();
             else if (currentPhase === 'voting') renderVotingPhase();
        }
    }
    
    // --- Game Logic Functions (Leader) ---
    
    function startNewRound() {
        if (!isLeader) return;

        // --- LOGGING DE L'HISTORIQUE (VOTRE CODE EST DÃ‰JÃ€ CORRECT ICI) ---
        const completedRoundData = { ...localGameState };
        const updates = {}; 

        if ((localGameState.round || 0) > 0) {
            // GrÃ¢ce Ã  nos modifications, prepareRoundLog va maintenant inclure la confession si elle existe.
            const roundHistoryUpdate = HistoryLogger.prepareRoundLog(completedRoundData);
            if (roundHistoryUpdate) {
                Object.assign(updates, roundHistoryUpdate);
            }
        } else if (!localFullGameData.history) { 
            const summaryUpdate = HistoryLogger.prepareSummaryLog(localFullGameData, localPlayersData);
            if (summaryUpdate) {
                Object.assign(updates, summaryUpdate);
            }
        }

        let finalRoundsUntilConfession = localGameState.roundsUntilConfession;

        if (confessionModeEnabled) {
            let currentCountdown = localGameState.roundsUntilConfession;
            if (currentCountdown === undefined || currentCountdown === null || currentCountdown < 0) {
                // --- AMÃ‰LIORATION --- : Ratio de 3 Ã  5 tours
                currentCountdown = Math.floor(Math.random() * 3) + 2; // GÃ©nÃ¨re 3, 4, ou 5
                console.log(`Initializing confession countdown to ${currentCountdown} rounds.`);
            }
            currentCountdown--;
            console.log(`Rounds until confession: ${currentCountdown}`);
            if (currentCountdown <= 0) {
                startConfessionPhase();
                return;
            }
            finalRoundsUntilConfession = currentCountdown;
        }

        const usedIndicesObject = localGameState.usedQuestionIndices || {};
        const usedIndicesSet = new Set(Object.keys(usedIndicesObject).map(Number));
        const newQuestionData = getNewQuestion(usedIndicesSet);
        if (!newQuestionData) {
            console.error("Leader: Failed to get a new question.");
            return;
        }
        usedIndicesSet.add(newQuestionData.index);

        const newGameState = {
            round: (localGameState.round || 0) + 1,
            phase: 'voting',
            question: newQuestionData.question,
            roundsUntilConfession: confessionModeEnabled ? finalRoundsUntilConfession : null,
            votes: null, 
            results: null, 
            readyForNextRound: null,
            coinTosses: null, 
            activeToss: null,
            usedQuestionIndices: Object.fromEntries(usedIndicesSet.entries()),
            
            // CORRECTION FINALE : On nettoie les donnÃ©es de la confession pour le nouveau round.
            confessionData: null, 
            confessionResult: null
        };
        // --- MISE Ã€ JOUR ATOMIQUE ---
        updates['currentGame'] = newGameState;
        gameRef.update(updates).catch(error => console.error("Leader: Error starting new round with history logging:", error));
    }
    
    function calculateResultsAndTransition() { 
        if (!isLeader) return;
        const votes = localGameState.votes || {};
        const voteCounts = {};
        Object.keys(localPlayersData).forEach(playerId => {
            if(localPlayersData[playerId]) voteCounts[playerId] = 0;
        });
        Object.values(votes).forEach(votedForId => {
            if (voteCounts.hasOwnProperty(votedForId)) voteCounts[votedForId]++;
        });
        gameStateRef.update({ phase: 'results', results: voteCounts })
            .catch(error => console.error("Leader: Erreur transition vers results:", error));
    }

function startConfessionPhase() {
    if (!isLeader) return;
    
    // --- La logique pour trouver la question, le chooser, etc. reste la mÃªme ---
    const usedConfessionIndicesObj = localFullGameData.usedConfessionQuestionIndices || {};
    const usedIndicesSet = new Set(Object.keys(usedConfessionIndicesObj).map(Number));
    const newQuestionData = getNewConfessionQuestion(usedIndicesSet);
    
    if (!newQuestionData) {
        console.error("Leader: Failed to get a confession question. Aborting...");
        startNewRound(); // On retourne Ã  un round normal
        return;
    }
    usedIndicesSet.add(newQuestionData.index);

    const lastResults = localGameState.results || {};
    let maxVotes = -1;
    const tiedPlayers = [];

    Object.entries(lastResults).forEach(([playerId, votes]) => {
        if (localPlayersData[playerId]?.isConnected) { 
            if (votes > maxVotes) {
                maxVotes = votes;
                tiedPlayers.length = 0; 
                tiedPlayers.push(playerId);
            } else if (votes === maxVotes && maxVotes > 0) { // On ne prend en compte que les Ã©galitÃ©s s'il y a eu des votes.
                tiedPlayers.push(playerId);
            }
        }
    });

    let chooserId = null;
    if (tiedPlayers.length > 0) {
        chooserId = tiedPlayers[Math.floor(Math.random() * tiedPlayers.length)];
    } else {
        const connectedPlayerIds = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected);
        if (connectedPlayerIds.length > 0) {
           chooserId = connectedPlayerIds[Math.floor(Math.random() * connectedPlayerIds.length)];
        } else {
            console.warn("Confession phase aborted, no connected players.");
            startNewRound();
            return;
        }
    }
    
    const nextConfessionIn = Math.floor(Math.random() * 3) + 3;
    
    const updates = {};

    // 1. Mettre Ã  jour les champs de `currentGame` nÃ©cessaires pour la confession
    updates['/currentGame/phase'] = 'confession_selection';
    updates['/currentGame/roundsUntilConfession'] = nextConfessionIn;
    updates['/currentGame/confessionData'] = { 
        chooserId: chooserId, 
        targetId: null, 
        question: newQuestionData.question,
        judgments: null 
    };
    // On nettoie le 'ready' du tour prÃ©cÃ©dent
    updates['/currentGame/readyForNextRound'] = null; 

    // IMPORTANT : On ne touche PAS Ã  `votes`, `results`, `coinTosses`.
    // Ils sont prÃ©servÃ©s.

    // 2. Mettre Ã  jour la liste des questions de confession utilisÃ©es (Ã  la racine du lobby)
    updates['/usedConfessionQuestionIndices'] = Object.fromEntries(usedIndicesSet.entries());

    // 3. On envoie la mise Ã  jour atomique
    gameRef.update(updates).catch(error => console.error("Leader: Error starting confession phase:", error));
}
    
    function renderConfessionSelection() {
    const { chooserId, question } = localGameState.confessionData || {};
    const chooserPseudo = localPlayersData[chooserId]?.pseudo || 'Quelqu\'un';
    const isChooser = currentUserId === chooserId;

    // Remplir le texte de la question dans son cadre
    confessionQuestionTextSelection.textContent = question || "Chargement de la question...";
    confessionQuestionTextSelection.classList.add('confession-question-hero', 'reveal-in');
    confessionQuestionTextSelection.style.display = 'block';

    if (isChooser) {
        // --- Vue pour le joueur qui choisit une victime ---
        confessionSelectionSubtitle.innerHTML = "Câ€™est ton moment de vengeanceâ€¦ Choisis qui devra rÃ©pondre Ã  cette question :";
        confessionSelectionInstruction.innerHTML = "ðŸ” Clique sur un joueur pour le dÃ©signer comme victime.";

        // Logique pour peupler les options (inchangÃ©e)
        playerConfessionTargetOptionsDiv.style.display = 'grid'; 
        playerConfessionTargetOptionsDiv.innerHTML = '';
        const immunePlayers = localFullGameData.immuneToConfession || {};
        Object.entries(localPlayersData).forEach(([playerId, player]) => {
            // if (!player.isConnected ) return;
            const btn = document.createElement('button');
            btn.className = 'player-vote-btn';
            btn.dataset.targetId = playerId;
            const img = document.createElement('img');
            img.src = player.avatarSrc;
            img.className = 'player-avatar';
            img.alt = "Avatar";
            btn.appendChild(img);
            const nameSpan = document.createElement('span');
            nameSpan.className = 'player-name-vote';
            nameSpan.textContent = player.pseudo;
            btn.appendChild(nameSpan);
            btn.addEventListener('click', handleConfessionTargetSelection);
            if (immunePlayers[playerId]) {
                btn.disabled = true;
                const immuneSpan = document.createElement('span');
                immuneSpan.textContent = 'ðŸ˜‡';
                immuneSpan.style.fontSize = '1.5em';
                btn.appendChild(immuneSpan);
                btn.style.opacity = 0.6;
            }
            playerConfessionTargetOptionsDiv.appendChild(btn);
        });

    } else {
        // --- Vue pour les autres joueurs qui attendent le choix ---
        confessionSelectionSubtitle.innerHTML = `âš ï¸ <strong>${chooserPseudo}</strong> est en train de choisir qui devra rÃ©pondre Ã  la question :`;
        confessionSelectionInstruction.innerHTML = "â³ Patientezâ€¦ la sentence va tomber.";
        playerConfessionTargetOptionsDiv.innerHTML = '';
        playerConfessionTargetOptionsDiv.style.display = 'none';
    }
}
    
   function handleConfessionTargetSelection(event) {
      // Utiliser .closest() est plus sÃ»r pour s'assurer qu'on attrape le bouton,
      // mÃªme si l'utilisateur clique sur l'avatar ou le nom Ã  l'intÃ©rieur.
      const button = event.target.closest('.player-vote-btn');
      if (!button) {
          console.error("Clic invalide, bouton non trouvÃ©.");
          return;
      }

      const targetId = button.dataset.targetId;
      console.log("targetId: ", targetId);

      // --- CORRECTION ET SÃ‰CURITÃ‰ ---
      // On vÃ©rifie que targetId n'est pas null, undefined, ou une chaÃ®ne vide.
      if (!targetId) {
          console.error("Impossible de sÃ©lectionner la cible : targetId est invalide.", targetId);
          alert("An error occurred while selecting the player. Please try again.");
          return; // On arrÃªte l'exÃ©cution pour ne rien envoyer Ã  Firebase.
      }

      console.log(`The avenger chose: ${targetId}. Sending signal to leader.`);
      
      // DÃ©sactiver tous les boutons pour Ã©viter un double clic
      document.querySelectorAll('#player-confession-target-options .player-vote-btn').forEach(b => b.disabled = true);
      
      // Appliquer un style visuel sur le bouton sÃ©lectionnÃ©
      button.classList.add('voted-for');

      // On envoie la valeur (maintenant validÃ©e) Ã  Firebase
      gameStateRef.child('confessionData/targetId').set(targetId)
          .catch(err => {
              console.error("Error selecting confession target:", err);
              // Si l'Ã©criture Ã©choue, rÃ©activer les boutons pour que l'utilisateur puisse rÃ©essayer.
              document.querySelectorAll('#player-confession-target-options .player-vote-btn').forEach(b => b.disabled = false);
              button.classList.remove('voted-for');
              alert("Failed to record your choice. Please try again.");
          });
  }
    
    function renderConfessionQuestion() {
    const { targetId, question, judgments = {} } = localGameState.confessionData || {};
    const targetPseudo = localPlayersData[targetId]?.pseudo || 'La victime';
    const isTarget = currentUserId === targetId;

    // Remplir le texte de la question dans son cadre
    confessionQuestionText.textContent = question || "En attente de la question...";
    confessionQuestionText.classList.add('confession-question-hero', 'reveal-in');
    confessionQuestionText.style.display = 'block';

    if (isTarget) {
        // --- Vue pour le joueur qui doit rÃ©pondre ---
        confessionQuestionSubtitle.innerHTML = "Câ€™est Ã  toi de jouer ! RÃ©ponds honnÃªtement ou invente, mais tu dois rÃ©pondre Ã  la question :";
        confessionAnswerPrompt.innerHTML = "ðŸ“¢ RÃ©ponds Ã  voix haute devant tout le monde.";
        confessionAnswerPrompt.style.display = 'block';
        confessionJudgmentArea.style.display = 'none';
    } else {
        // --- Vue pour les joueurs qui jugent ---
        confessionQuestionSubtitle.innerHTML = `ðŸŽ¯ <strong>${targetPseudo}</strong> est en train de rÃ©pondre Ã  la question :`;
        confessionJudgmentInstruction.innerHTML = "âœ… Clique sur <strong>CONVINCED</strong> si tu crois sa rÃ©ponse, âŒ sur <strong>NOT BUYING IT</strong> si tu penses quâ€™il/elle ment.";
        
        confessionAnswerPrompt.style.display = 'none';
        confessionJudgmentArea.style.display = 'block';

        // Logique pour les boutons de jugement et la barre de progression (inchangÃ©e)
        const hasJudged = !!judgments[currentUserId];
        judgmentConvincedBtn.disabled = hasJudged;
        judgmentNotConvincedBtn.disabled = hasJudged;
        judgmentStatus.textContent = hasJudged ? "Ton verdict est enregistrÃ©." : "En attente de ton verdict...";
    }
    const meterFill = document.querySelector('#jury-meter .jury-fill');
    if (meterFill) { // On vÃ©rifie juste que notre sÃ©lecteur a bien fonctionnÃ©
        const totalEligible = Object.keys(localPlayersData).filter(id => localPlayersData[id]?.isConnected && id !== targetId).length;
        const currentVotes = Object.keys(judgments).length;
        const percentage = (totalEligible > 0) ? (currentVotes / totalEligible) * 100 : 0;
        meterFill.style.width = percentage + '%';
    }

}

    function handleJudgmentClick(vote) {
        const { targetId, chooserId } = localGameState.confessionData || {};
        if (currentUserId === targetId) return;
        gameStateRef.child(`confessionData/judgments/${currentUserId}`).set(vote)
            .catch(err => console.error("Error sending judgment:", err));
    }
    
   function calculateConfessionVerdict() {
        if (!isLeader) return;
        
        const { judgments, targetId, chooserId, question } = localGameState.confessionData;
        const targetPseudo = localPlayersData[targetId]?.pseudo || 'The victim';
        
        const convincedVotes = Object.values(judgments || {}).filter(v => v === 'convaincu').length;
        const totalVotes = Object.keys(judgments || {}).length;
        const verdict = (totalVotes > 0 && convincedVotes >= totalVotes / 2) ? 'convaincu' : 'pas convaincu';
        
        const confessionResult = {
            playerName: targetPseudo,
            outcome: verdict,
            details: `${convincedVotes} / ${totalVotes} convinced`
        };

        // --- LOGGING SUPPRIMÃ‰ D'ICI ---
        // On ne touche plus Ã  l'historique Ã  cette Ã©tape.
        const updates = {};
        let immunePlayers = localFullGameData.immuneToConfession || {};
        if (verdict === 'convaincu') {
            immunePlayers[targetId] = true;
        }

        const connectedPlayerIds = Object.keys(localPlayersData).filter(id => localPlayersData[id].isConnected);
        const immuneConnectedCount = connectedPlayerIds.filter(id => immunePlayers[id]).length;
        
        // Si tous les joueurs connectÃ©s sont devenus immunes, on reset la liste.
        if (immuneConnectedCount >= connectedPlayerIds.length) { 
            console.log("All connected players are immune! Resetting the list.");
            updates['/immuneToConfession'] = null; // Vide la liste
        } else if (verdict === 'convaincu') {
            updates[`/immuneToConfession/${targetId}`] = true; // Ajoute le joueur
        }
        
        // Mise Ã  jour de l'Ã©tat du jeu pour la phase de rÃ©sultat de la confession
        updates['/currentGame/phase'] = 'confession_result'; 
        updates['/currentGame/confessionResult'] = confessionResult; // On stocke le rÃ©sultat
        updates['/currentGame/readyForNextRound'] = null;  

        gameRef.update(updates);
    }

    function renderConfessionResultPhase() {
      const confessionResult = localGameState.confessionResult;
      if (confessionResult) {
        const outcomeText = confessionResult.outcome === 'convaincu'
          ? `convinced the jury and becomes <strong>immune</strong>! ðŸ˜‡`
          : `did <strong>NOT</strong> convince the jury and remains a target! ðŸ˜ˆ`;

        // 1) on pose le contenu
        confessionVerdictDisplay.innerHTML = `
          <p style="font-size: 1.1em;">
            <strong>${confessionResult.playerName}</strong> ${outcomeText}
          </p>
          <p style="font-size: 0.9em; color: var(--clr-primary-green)">
            (${confessionResult.details})
          </p>`;

        // 2) ensuite on ajoute le stamp par-dessus
        showVerdictStamp(confessionResult.outcome);
      } else {
        confessionVerdictDisplay.innerHTML = `<p class="status-message">Waiting for the verdict...</p>`;
      }

      const readyForNext = localGameState.readyForNextRound || {};
      isReadyForNext = !!readyForNext[currentUserId];
      nextRoundBtnConfession.disabled = isReadyForNext;
      nextRoundBtnConfession.textContent = isReadyForNext ? "Ready!" : "Ready for the next round?";
      const connectedReadyCount = Object.keys(readyForNext).filter(id => localPlayersData[id]?.isConnected).length;
      readyStatusConfession.textContent = `${connectedReadyCount} / ${connectedPlayersCount} players are ready!`;
    }
    
    // --- Startup & Teardown ---
    document.addEventListener('DOMContentLoaded', initializeGame);
    window.addEventListener('beforeunload', () => { console.log("onDisconnect will handle the disconnection."); });
</script>