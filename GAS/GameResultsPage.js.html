<script>
/**
 * @file GameResultsPage.js
 * Handles fetching, processing, and rendering the final results of a game.
 * It uses Chart.js and Vis.js for data visualization.
 */

// --- BADGES DEF ---
// Defines all possible badges, their descriptions, and a function to format
// the description with player-specific data.
const BADGE_MANIFEST = {
    voteMagnet:    { 
        icon: 'üß≤', title: 'Vote Magnet', 
        desc: 'The most targeted player overall.',
        formatDesc: (p) => `The most targeted player overall, with ${p.totalVotesReceived} votes received.`
    },
    ninja:         { 
        icon: 'ü•∑', title: 'Ninja', 
        desc: 'The most evasive player (fewest votes received).',
        formatDesc: (p) => `The most evasive player, with only ${p.totalVotesReceived} votes received.`
    },
    leader:        { 
        icon: 'üëë', title: 'The Leader', 
        desc: 'Most often voted with the majority in a round.',
        formatDesc: (p) => `Most often voted with the majority (${p.leaderVotes} times).`
    },
    maverick:      { 
        icon: 'üê∫', title: 'The Maverick', 
        desc: 'Most often voted for a player who received no other votes.',
        formatDesc: (p) => `Most often voted for a solo target (${p.maverickVotes} times).`
    },
    vendetta:      { 
        icon: 'üéØ', title: 'The Vendetta', 
        desc: 'Voted for the same person more than anyone else.',
        formatDesc: (p) => {
            const maxVotes = Math.max(0, ...Object.values(p.votesCast));
            return `Voted for the same person ${maxVotes} times, more than anyone else's vendetta.`;
        }
    },
    serialTargeter:{ 
        icon: 'üî´', title: 'Serial Targeter', 
        desc: 'Had the longest streak of voting for the same person.',
        formatDesc: (p) => `Had the longest streak of voting for the same person (${p.maxVoteStreak} rounds in a row).`
    },
    maskedAvenger: { 
        icon: 'üé≠', title: 'Masked Avenger', 
        desc: 'Most often voted for someone who had just targeted them.',
        formatDesc: (p) => `Avenged themselves by voting for their previous attacker ${p.avengerKills} times.`
    },
    inquisitor:    { 
        icon: 'üïµÔ∏è', title: 'Grand Inquisitor', 
        desc: 'Was chosen to judge a confession most often.',
        formatDesc: (p) => `Was chosen to judge a confession ${p.timesAsInquisitor} times.`
    },
    untouchable:   { 
        icon: 'üõ°Ô∏è', title: 'The Untouchable', 
        desc: 'Became immune from confessions most often.',
        formatDesc: (p) => `Became immune from confessions ${p.timesUntouchable} times.`
    },
    diplomat:      { 
        icon: 'üïäÔ∏è', title: 'The Diplomat', 
        desc: 'Had the most rounds where they received zero votes.',
        formatDesc: (p) => `Had the most rounds with zero votes received (${p.diplomatRounds} rounds).`
    },
    godOfLuck:     { 
        icon: 'üçÄ', title: 'God of Luck', 
        desc: 'Had the best coin toss success rate.',
        formatDesc: (p) => {
            const rate = p.totalTosses > 0 ? Math.round((p.successfulTosses / p.totalTosses) * 100) : 0;
            return `Had the best coin toss success rate (${rate}% success - ${p.successfulTosses}/${p.totalTosses}).`;
        }
    },
    inAFog:        { 
        icon: 'üòµ‚Äçüí´', title: 'In a Fog', 
        desc: 'Had the worst coin toss success rate.',
        formatDesc: (p) => {
            const rate = p.totalTosses > 0 ? Math.round((p.successfulTosses / p.totalTosses) * 100) : 0;
            return `Had the worst coin toss success rate (${rate}% success - ${p.successfulTosses}/${p.totalTosses}).`;
        }
    },
    notConvincing: { 
        icon: 'ü§•', title: 'Not Convincing', 
        desc: 'Failed the most confessions.',
        formatDesc: (p) => `Failed the most confessions (${p.confessionFails} fails).`
    },
};

// Transforms the `BADGE_LIST` array (loaded from `BadgeData.html`) into a 
// key-value map for instant lookup of badge image sources by their ID.
const badgeImageData = (typeof BADGE_LIST !== 'undefined' && Array.isArray(BADGE_LIST))
  ? BADGE_LIST.reduce((acc, badge) => {
      acc[badge.id] = badge.src;
      return acc;
    }, {})
  : {};

// --- CHARTING CONSTANTS & THEME ---
const THEME_COLORS = {
    orange: 'rgba(249, 122, 61, 1)',
    green: 'rgba(42, 87, 87, 1)',
    teal: 'rgba(93, 192, 166, 1)',
    purple: 'rgba(74, 47, 72, 1)',
    yellow: 'rgba(249, 212, 35, 1)',
    lightBg: 'rgba(253, 246, 233, 1)',
    textDark: '#4A2F48',
    textLight: '#FFFFFF',
    gridColor: 'rgba(74, 47, 72, 0.1)'
};

const CHART_PALETTE = [
    THEME_COLORS.orange,  // warm
    '#6495ED',            // cool
    THEME_COLORS.green,   // cool
    THEME_COLORS.yellow,  // warm
    THEME_COLORS.teal,    // cool
    '#FF4500',            // warm
    THEME_COLORS.purple,  // cool
    '#C3E63F',            // warm
    '#40E0D0',            // cool
    '#E6B800',            // warm
    '#8A2BE2',            // cool
    '#DC143C',            // warm
    '#FF69B4',            // warm
    '#00FA9A',            // cool
    '#DA70D6',            // cool
    '#7FFF00'             // warm
];

const CHART_DEFAULTS = {
    font: {
        family: "'Poppins', sans-serif",
        color: THEME_COLORS.textDark
    },
    tooltip: {
        enabled: true,
        backgroundColor: THEME_COLORS.purple,
        titleColor: THEME_COLORS.textLight,
        bodyColor: THEME_COLORS.textLight,
        titleFont: { family: "'Poppins', sans-serif", weight: 'bold' },
        bodyFont: { family: "'Poppins', sans-serif" },
        padding: 10,
        cornerRadius: 8,
        borderColor: THEME_COLORS.teal,
        borderWidth: 1
    }
};

// --- DYNAMIC SECTION CONFIGURATION ---
// This array drives the dynamic creation of the results page. Each object
// defines a section card, its title, subtitle, HTML content, and the function
// responsible for rendering its specific visualization.
const SECTIONS_CONFIG = [
    {
        id: 'summary-card',
        content: `<div class="summary-grid">
                      <div class="summary-item"><span class="summary-value" id="total-rounds">--</span><span class="summary-label">Rounds Played</span></div>
                      <div class="summary-item"><span class="summary-value" id="game-duration">--:--</span><span class="summary-label">Game Duration</span></div>
                  </div>`,
        renderFn: (data) => renderSummary(data.gameSummary)
    },
    {
        id: 'badges-card',
        title: 'Player Awards & Titles',
        subtitle: 'The official post-game honors. Hover over an icon to learn more.',
        content: `<div id="player-badges-container" class="player-badges-grid"></div>`,
        renderFn: (data) => renderPlayerBadges(data.playerAwards, data.playerStats)
    },
    {
        id: 'evolution-chart-card',
        title: 'Score Evolution Over Rounds',
        subtitle: "See who became a target and when. Each line represents a player's cumulative votes received.",
        content: `<div class="chart-container"><canvas id="scoreEvolutionChart"></canvas></div>`,
        renderFn: (data) => renderScoreEvolutionChart(data.playerStats, data.gameSummary.totalRounds)
    },
    {
        id: 'ranking-card',
        title: 'Final Ranking: The Most Targeted',
        subtitle: 'Who was the main character of this game?',
        content: `<div class="chart-container"><canvas id="rankingChart"></canvas></div>`,
        renderFn: (data) => renderRankingChart(data.playerStats)
    },
    {
        id: 'heatmap-card',
        title: 'Vote Heatmap: Who Targeted Whom?',
        subtitle: 'The darker the cell, the more votes were cast. Hover for details.',
        content: `<div class="heatmap-wrapper"><div id="heatmap-container"></div></div>`,
        renderFn: (data) => renderHeatmap(data.playerStats, Object.keys(data.players))
    },
    {
        id: 'vote-composition-card',
        title: 'Voter Breakdown: Who Targeted Whom?',
        subtitle: 'Each bar is a voter. Each colored segment is a player they voted for.',
        content: `<div id="stacked-chart-wrapper"><div class="chart-container" style="height: 400px;"><canvas id="stackedVoteChart"></canvas></div><div id="stacked-chart-legend" class="custom-legend-container"></div></div>`,
        renderFn: (data) => renderStackedVoteChart(data.playerStats)
    },
    {
        id: 'network-graph-card',
        title: 'The Target Network',
        subtitle: 'An arrow shows who voted for whom. Thicker arrows mean more votes. Drag players around!',
        content: `<div id="network-graph-container"></div>`,
        renderFn: (data) => renderNetworkGraph(data.playerStats)
    },
    {
        id: 'personal-radars-card',
        title: 'Personal Player Breakdown',
        subtitle: "A radar chart showing each player's strategic profile. Values are percentages (0-100).",
        content: `<div id="personal-radars-container" class="personal-radars-grid"></div>`,
        renderFn: (data) => renderPersonalRadars(data.playerStats, data.gameFeatures)
    }
];


// --- INITIALIZATION --

document.addEventListener('DOMContentLoaded', () => {
    if (!gameId) {
        showError("No Game ID provided in the URL.");
        return;
    }
    if (typeof firebase === 'undefined' || typeof Chart === 'undefined') {
        showError("A required library (Firebase or Chart.js) failed to load.");
        return;
    }

    document.getElementById('game-id-display').textContent = `#${gameId}`;
    initializeFirebaseAndFetchData();
    setupHomeLinks();
});

/**
 * Displays an error message to the user.
 * @param {string} message - The error message to display.
 */
function showError(message) {
    document.getElementById('loading-state').style.display = 'none';
    document.getElementById('results-content').style.display = 'none';
    const errorState = document.getElementById('error-state');
    const errorText = document.getElementById('error-text');
    errorText.textContent = message;
    errorState.style.display = 'block';
    console.error(message);
}

/**
 * Sets up the "Home" and "Play Again" links, accounting for Google Apps Script environment.
 */
function setupHomeLinks() {
    const getWebAppUrl = () => new Promise((resolve) => {
        if (typeof google !== 'undefined' && google.script && google.script.run) {
            google.script.run.withSuccessHandler(url => resolve(url)).getScriptUrl();
        } else {
            resolve(window.location.origin + window.location.pathname);
        }
    });

    getWebAppUrl().then(baseUrl => {
        const homeUrl = `${baseUrl}?page=home`;
        document.getElementById('home-link').href = homeUrl;
        document.getElementById('error-home-link').href = homeUrl;
    });
}

/**
 * Initializes the Firebase connection and fetches the game data.
 */
function initializeFirebaseAndFetchData() {
    try {
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        firebase.auth().onAuthStateChanged(user => {
            if (user) {
                const gameRef = firebase.database().ref(`lobbies/${gameId}`);
                gameRef.once('value', snapshot => {
                    if (!snapshot.exists()) {
                        showError(`No data found for Game ID #${gameId}.`);
                        return;
                    }
                    processAndRenderData(snapshot.val());
                }, error => {
                    showError(`Permission Denied. You may not have been a player in game #${gameId}.`);
                });
            } else {
                showError("You must be logged in to view game results.");
            }
        });
    } catch (error) {
        showError(`Initialization error: ${error.message}`);
    }
}

// --- DATA PROCESSING ---

/**
 * Processes raw game data from Firebase to calculate all necessary player statistics.
 * @param {object} gameData - The raw data object from Firebase.
 * @returns {object} An object containing structured data for rendering.
 */
function processGameData(gameData) {
    if (!gameData || !gameData.history || !gameData.history.summary || !gameData.history.summary.initialPlayers || !gameData.history.rounds) {
        throw new Error("Game data is incomplete.");
    }

    const { history, endTime } = gameData;
    const { summary, rounds: rawRounds } = history;
    const { initialPlayers, startTime } = summary;
    const players = initialPlayers;
    const rounds = Object.values(rawRounds).filter(Boolean);
    const totalRounds = rounds.length;

    const playerStats = {};
    
    // Initialize stats object for each player
    const playerStreakTrackers = {}; 

    Object.keys(players).forEach(playerId => {
        playerStats[playerId] = {
            id: playerId, pseudo: players[playerId].pseudo, avatarSrc: players[playerId].avatarSrc,
            totalVotesReceived: 0, votesCast: {}, confessionFails: 0, successfulTosses: 0, totalTosses: 0,
            leaderVotes: 0, maverickVotes: 0, timesAsInquisitor: 0, timesUntouchable: 0,
            avengerKills: 0, diplomatRounds: 0, maxVoteStreak: 0, cumulativeScores: [], 
            cumulativeScoreTemp: 0,
            
            pressureRounds: 0, soloAccusationRounds: 0, votedForWinnerRounds: 0,
            judgmentsGiven: 0, judgmentsSevere: 0, confessionsAsTarget: 0,
            confessionsPersuasive: 0,
        };
        
        // Initialize tracker for 'Serial Targeter' badge
        playerStreakTrackers[playerId] = { currentTarget: null, currentStreak: 0 };
    });

    let hadConfessionJudgments = false;
    let hadConfessionTargets = false;
    let hadCoinTosses = false;
    
    // For the 'Masked Avenger' badge, we need to track the previous round's votes.
    let previousRoundVotes = {};

     // Iterate through each round to aggregate stats
    rounds.forEach((round, index) => {
        const voteCountsThisRound = {};
        const voters = round.votes || {};
        
        Object.values(voters).forEach(targetId => {
            voteCountsThisRound[targetId] = (voteCountsThisRound[targetId] || 0) + 1;
        });
        const maxVotes = Math.max(0, ...Object.values(voteCountsThisRound));
        const majorityVotedPlayers = maxVotes > 0 ? Object.keys(voteCountsThisRound).filter(id => voteCountsThisRound[id] === maxVotes) : [];

        // Calculate vote-based stats
        Object.entries(voters).forEach(([voterId, targetId]) => {
            if (!playerStats[voterId] || !playerStats[targetId]) return;
            
            playerStats[targetId].totalVotesReceived++;
            playerStats[voterId].votesCast[targetId] = (playerStats[voterId].votesCast[targetId] || 0) + 1;
            
            // --- BADGE-SPECIFIC CALCULATIONS ---
            // 'Leader': Voted for one of the most-targeted players
            if (majorityVotedPlayers.includes(targetId)) {
                playerStats[voterId].leaderVotes++;
            }
            // 'Maverick': Voted for someone who received no other votes
            if (voteCountsThisRound[targetId] === 1) {
                playerStats[voterId].maverickVotes++;
            }
            // 'Masked Avenger': Voted for someone who targeted them in the previous round
            if (previousRoundVotes[targetId] === voterId) {
                playerStats[voterId].avengerKills++;
            }
            
            // Update streak for 'Serial Targeter' badge
            const tracker = playerStreakTrackers[voterId];
            if (tracker.currentTarget === targetId) {
                tracker.currentStreak++;
            } else {
                tracker.currentTarget = targetId;
                tracker.currentStreak = 1;
            }
            if (tracker.currentStreak > playerStats[voterId].maxVoteStreak) {
                playerStats[voterId].maxVoteStreak = tracker.currentStreak;
            }

            // For radar charts
            if (voteCountsThisRound[targetId] === 1) playerStats[voterId].soloAccusationRounds++;
            if (majorityVotedPlayers.includes(targetId)) playerStats[voterId].votedForWinnerRounds++;
        });
        
        // 'Pressure' stat (Radar): for players who were the majority target
        majorityVotedPlayers.forEach(winnerId => { if (playerStats[winnerId]) playerStats[winnerId].pressureRounds++; });
        
        // 'Diplomat' badge: check for players who received no votes this round
        Object.keys(players).forEach(playerId => {
            if (!voteCountsThisRound[playerId]) {
                playerStats[playerId].diplomatRounds++;
            }
        });
        
        // Update cumulative scores for the evolution chart
        Object.keys(players).forEach(playerId => {
            playerStats[playerId].cumulativeScoreTemp += voteCountsThisRound[playerId] || 0;
            playerStats[playerId].cumulativeScores.push(playerStats[playerId].cumulativeScoreTemp);
        });

       // Calculate confession-based stats
        if (round.confessionEvent) {
            const { chooserId, targetId, outcome, judgments, immunePlayerId } = round.confessionEvent;
            
            if (playerStats[chooserId]) playerStats[chooserId].timesAsInquisitor++;
            if (playerStats[immunePlayerId]) playerStats[immunePlayerId].timesUntouchable++;
            if (outcome === 'pas convaincu' && playerStats[targetId]) {
                playerStats[targetId].confessionFails++;
            }

            if (playerStats[targetId]) {
                hadConfessionTargets = true;
                playerStats[targetId].confessionsAsTarget++;
                if (outcome === 'convaincu') playerStats[targetId].confessionsPersuasive++;
            }
            
            if (judgments && typeof judgments === 'object' && Object.keys(judgments).length > 0) {
                hadConfessionJudgments = true;
                Object.entries(judgments).forEach(([judgeId, judgment]) => {
                    if (playerStats[judgeId]) {
                        playerStats[judgeId].judgmentsGiven++;
                        if (judgment === 'pas convaincu') playerStats[judgeId].judgmentsSevere++;
                    }
                });
            }
        }
        
        if (round.coinTosses && Object.keys(round.coinTosses).length > 0) {
            hadCoinTosses = true;
            Object.entries(round.coinTosses).forEach(([playerId, tossData]) => {
                if (playerStats[playerId]) {
                    playerStats[playerId].totalTosses++;
                    if (tossData.result === 'HEADS') playerStats[playerId].successfulTosses++;
                }
            });
        }

        // Update the vote history for the next round ('Masked Avenger')
        previousRoundVotes = voters;
    });

    // Final step: Calculate percentages for radar charts
    Object.values(playerStats).forEach(p => {
        delete p.cumulativeScoreTemp;
        p.pressurePercent = totalRounds > 0 ? (p.pressureRounds / totalRounds) * 100 : 0;
        p.soloAccusationPercent = totalRounds > 0 ? (p.soloAccusationRounds / totalRounds) * 100 : 0;
        p.votedForWinnerPercent = totalRounds > 0 ? (p.votedForWinnerRounds / totalRounds) * 100 : 0;
        p.severityPercent = p.judgmentsGiven > 0 ? (p.judgmentsSevere / p.judgmentsGiven) * 100 : 0;
        p.persuasionPercent = p.confessionsAsTarget > 0 ? (p.confessionsPersuasive / p.confessionsAsTarget) * 100 : 0;
        p.headsPercent = p.totalTosses > 0 ? (p.successfulTosses / p.totalTosses) * 100 : 0;
    });

    return {
        gameSummary: { startTime, endTime, totalRounds },
        playerStats,
        players,
        gameFeatures: { hadConfessionJudgments, hadConfessionTargets, hadCoinTosses }
    };
}

// --- RENDERING ORCHESTRATION ---

/**
 * Main orchestration function that processes data and triggers the rendering sequence.
 * @param {object} gameData - The raw data object from Firebase.
 */

function processAndRenderData(gameData) {
    try {
        const processedData = processGameData(gameData);
        if (!processedData) return;
        
        // Calculate badges, which are needed for rendering
        processedData.playerAwards = calculateAndAssignBadges(processedData.playerStats);
        document.getElementById('loading-state').style.display = 'none';
        
        const mainContainer = document.getElementById('results-content');
        mainContainer.style.display = 'block';

        // Start the sequential rendering process
        renderSectionsInSequence(processedData);

    } catch (error) {
        showError(error.message);
    }
}

/**
 * Dynamically creates and animates each results section in a staggered sequence.
 * This provides a more engaging user experience as the report builds itself.
 * @param {object} processedData - The complete, processed game data.
 */
function renderSectionsInSequence(processedData) {
    const mainContainer = document.getElementById('results-content');
    mainContainer.innerHTML = ''; 

    SECTIONS_CONFIG.forEach((sectionConfig, index) => {
        const sectionEl = document.createElement('section');
        sectionEl.id = sectionConfig.id;
        sectionEl.className = 'results-card revealable'; 

        let innerHTML = '';
        if (sectionConfig.title) innerHTML += `<h2>${sectionConfig.title}</h2>`;
        if (sectionConfig.subtitle) innerHTML += `<p class="card-subtitle">${sectionConfig.subtitle}</p>`;
        innerHTML += sectionConfig.content;
        sectionEl.innerHTML = innerHTML;

        mainContainer.appendChild(sectionEl);

        setTimeout(() => {
            sectionEl.classList.add('is-visible');
            
            
            if (sectionConfig.renderFn) {
                sectionConfig.renderFn(processedData);
            }
        }, index * 6000);
    });

    setTimeout(() => {
        const footerActions = document.createElement('div');
        footerActions.className = 'footer-actions';
        footerActions.innerHTML = `<a href="#" id="home-link" class="button-like-link">Play Again!</a>`;
        mainContainer.appendChild(footerActions);
        setupHomeLinks(); // Re-brancher le lien
    }, SECTIONS_CONFIG.length * 300);
}

// --- BADGE CALCULATION ---

/**
 * Determines which players have earned which badges based on their stats.
 * Badges are only awarded if the qualifying score is significant (e.g., > 0).
 * @param {object} playerStats - The calculated statistics for all players.
 * @returns {object} An object mapping player IDs to an array of badges they've won.
 */
function calculateAndAssignBadges(playerStats) {
    const playersArray = Object.values(playerStats);
    if (playersArray.length === 0) return {};

    const awards = {};
    Object.keys(playerStats).forEach(id => { awards[id] = []; });

    // Helper to assign a badge to a list of winning players
    const assignBadge = (badgeKey, playersToAward) => {
        if (!playersToAward || playersToAward.length === 0) return;
        playersToAward.forEach(p => {
            awards[p.id].push({ 
                key: badgeKey, 
                ...BADGE_MANIFEST[badgeKey],
                playerData: p  // Store the full player object to allow dynamic description formatting
            });
        });
    };

    // Helper function to find players who have the best score for a given metric
    const findWinners = (metric, compareFn = (a, b) => b - a, threshold = 0) => {
        const candidates = playersArray.filter(p => typeof p[metric] === 'number');
        if (candidates.length === 0) return [];
        const sorted = [...candidates].sort((a, b) => compareFn(a[metric], b[metric]));
        const bestScore = sorted[0][metric];
        if (bestScore <= threshold) return [];
        return sorted.filter(p => p[metric] === bestScore);
    };
    
    // Helper for ratio-based badges like luck
    const findRatioWinner = (compareFn) => {
        const candidates = playersArray.filter(p => p.totalTosses > 0);
        if (candidates.length === 0) return [];
        candidates.sort((a,b) => {
            const ratioA = a.successfulTosses / a.totalTosses;
            const ratioB = b.successfulTosses / b.totalTosses;
            return compareFn(ratioA, ratioB);
        });
        const bestRatio = candidates[0].successfulTosses / candidates[0].totalTosses;
        return candidates.filter(p => (p.successfulTosses / p.totalTosses) === bestRatio);
    };
    
    // Assign each badge using the helper functions, applying a relevance threshold
    assignBadge('voteMagnet', findWinners('totalVotesReceived'));
    const ninjaWinners = findWinners('totalVotesReceived', (a, b) => a - b);
    if (ninjaWinners.length < playersArray.length) {
      assignBadge('ninja', ninjaWinners);
    }
    assignBadge('leader', findWinners('leaderVotes'));
    assignBadge('maverick', findWinners('maverickVotes'));
    assignBadge('inquisitor', findWinners('timesAsInquisitor'));
    assignBadge('untouchable', findWinners('timesUntouchable'));
    assignBadge('maskedAvenger', findWinners('avengerKills'));
    assignBadge('diplomat', findWinners('diplomatRounds'));
    assignBadge('serialTargeter', findWinners('maxVoteStreak', (a, b) => b - a, 1));
    assignBadge('notConvincing', findWinners('confessionFails'));

     // Special logic for 'Vendetta' badge
    let maxVotesToOne = 0;
    let vendettaWinner = [];
    playersArray.forEach(p => {
        const mostVotes = Math.max(0, ...Object.values(p.votesCast));
        if (mostVotes > maxVotesToOne) {
            maxVotesToOne = mostVotes;
            vendettaWinner = [p];
        } else if (mostVotes === maxVotesToOne && maxVotesToOne > 0) {
            vendettaWinner.push(p);
        }
    });
    if (maxVotesToOne > 1) {
        assignBadge('vendetta', vendettaWinner);
    }

    // Assign luck-based badges
    assignBadge('godOfLuck', findRatioWinner((a, b) => b - a));
    assignBadge('inAFog', findRatioWinner((a, b) => a - b));   
    
    return awards;
}

// --- SPECIFIC SECTION RENDERERS ---

/**
 * Renders the summary card with total rounds and game duration.
 * @param {object} gameSummary - The summary data.
 */
function renderPlayerBadges(playerAwards, playerStats) {
    const container = document.getElementById('player-badges-container');
    if (!container) return;
    container.innerHTML = ''; 

    const playerIds = Object.keys(playerStats);

    playerIds.forEach((playerId, cardIndex) => {
        const player = playerStats[playerId];
        const awards = playerAwards[playerId] || [];
        
        const card = document.createElement('div');
        card.className = 'player-badge-card';

        let badgesHTML = '';
        if (awards.length > 0) {
            badgesHTML = awards.map(badge => {
                const description = badge.formatDesc ? badge.formatDesc(badge.playerData) : badge.desc;
                const imageSrc = badgeImageData[badge.key];
                const imageTag = imageSrc ? `<img src="${imageSrc}" alt="${badge.title}" class="badge-icon-img">` : '';
                return `<span class="badge-item" data-tooltip="${badge.title}: ${description}">${imageTag}</span>`;
            }).join('');
        } else {
            badgesHTML = `<p class="no-badges-message">No special awards this time.</p>`;
        }
        
        card.innerHTML = `
            <div class="player-badge-info">
                <img src="${player.avatarSrc}" alt="${player.pseudo}" class="player-badge-avatar">
                <span class="player-badge-name">${player.pseudo}</span>
            </div>
            <div class="player-badges-list">${badgesHTML}</div>`;
            
        container.appendChild(card);
        
        setTimeout(() => {
            card.classList.add('card-is-visible');

            if (awards.length > 0) {
                const badgeItems = card.querySelectorAll('.badge-item');
                
                badgeItems.forEach((badgeItem, badgeIndex) => {
                    setTimeout(() => {
                        badgeItem.classList.add('pop-in');
                    }, badgeIndex * 400); 
                });
            }
        }, cardIndex * 2000); 
    });
}

function renderSummary(gameSummary) {
    document.getElementById('total-rounds').textContent = gameSummary.totalRounds;
    const { startTime, endTime } = gameSummary;
    let durationText = "--:--";
    if (typeof startTime === 'number' && typeof endTime === 'number' && (endTime - startTime) > 0) {
        const durationSeconds = Math.round((endTime - startTime) / 1000);
        const minutes = Math.floor(durationSeconds / 60);
        const seconds = durationSeconds % 60;
        durationText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    document.getElementById('game-duration').textContent = durationText;
}


/**
 * Renders the score evolution line chart with a progressive drawing animation.
 * @param {object} playerStats - The player statistics object.
 * @param {number} totalRounds - The total number of rounds played.
 */
function renderScoreEvolutionChart(playerStats, totalRounds) {
    const ctx = document.getElementById('scoreEvolutionChart').getContext('2d');

    if (window.myScoreChart) {
        window.myScoreChart.destroy();
    }

    const datasets = Object.values(playerStats).map((player, index) => ({
        label: player.pseudo,
        data: player.cumulativeScores,
        borderColor: CHART_PALETTE[index % CHART_PALETTE.length],
        fill: false,
        tension: 0.3,
        borderWidth: 4,
        pointBackgroundColor: CHART_PALETTE[index % CHART_PALETTE.length],
        pointBorderColor: THEME_COLORS.lightBg,
        pointBorderWidth: 2,
        pointRadius: 5,
        pointHoverRadius: 8
    }));
    
   
    const totalDuration = 3000; 
    const delayBetweenPoints = totalDuration / totalRounds;

    const previousY = (ctx) => {
        if (ctx.index === 0) {
            return ctx.chart.scales.y.getPixelForValue(0);
        } 
        else {
            return ctx.chart.getDatasetMeta(ctx.datasetIndex).data[ctx.index - 1].getProps(['y'], true).y;
        }
    };
    
    const progressiveAnimation = {
        x: {
            type: 'number',
            easing: 'linear',
            duration: delayBetweenPoints,
            from: NaN,
            delay(ctx) {
                if (ctx.type !== 'data' || ctx.xStarted) {
                    return 0;
                }
                ctx.xStarted = true; 
                return ctx.index * delayBetweenPoints;
            }
        },
        y: {
            type: 'number',
            easing: 'linear',
            duration: delayBetweenPoints,
            from: previousY, 
            delay(ctx) {
                if (ctx.type !== 'data' || ctx.yStarted) {
                    return 0;
                }
                ctx.yStarted = true;
                return ctx.index * delayBetweenPoints; 
            }
        }
    };

    window.myScoreChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: Array.from({ length: totalRounds }, (_, i) => `Round ${i + 1}`),
            datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        font: CHART_DEFAULTS.font,
                        boxWidth: 40,
                        boxHeight: 2,
                        useBorderRadius: true,
                        borderRadius: 1
                    }
                },
                tooltip: CHART_DEFAULTS.tooltip
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Cumulative Votes Received', font: CHART_DEFAULTS.font },
                    ticks: { precision: 0, font: CHART_DEFAULTS.font },
                    grid: { color: THEME_COLORS.gridColor }
                },
                x: {
                    title: { display: true, text: 'Game Rounds', font: CHART_DEFAULTS.font },
                    ticks: { font: CHART_DEFAULTS.font },
                    grid: { color: THEME_COLORS.gridColor }
                }
            },
            animation: progressiveAnimation 
        }
    });
}

/**
 * Renders the final ranking bar chart with avatar labels and a staggered animation.
 * @param {object} playerStats - The player statistics object.
 */
function renderRankingChart(playerStats) {
    const sortedPlayers = Object.values(playerStats).sort((a, b) => b.totalVotesReceived - a.totalVotesReceived);
    const avatarImages = sortedPlayers.map(p => { const img = new Image(); img.src = p.avatarSrc; return img; });
    const avatarLabelsPlugin = {
        id: 'avatarLabels',
        afterDraw(chart) {
            const { ctx, scales: { y } } = chart;
            const imageSize = 30;
            ctx.save();
            y.ticks.forEach((tick, index) => {
                const yPos = y.getPixelForTick(index);
                const xPos = y.left - imageSize - 10;
                ctx.beginPath();
                ctx.arc(xPos + imageSize / 2, yPos, imageSize / 2, 0, 2 * Math.PI);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(avatarImages[index], xPos, yPos - imageSize / 2, imageSize, imageSize);
                ctx.restore();
                ctx.save();
            });
            ctx.restore();
        }
    };
     const ctx = document.getElementById('rankingChart').getContext('2d');
    new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedPlayers.map(p => p.pseudo),
            datasets: [{
                label: 'Total Votes Received',
                data: sortedPlayers.map(p => p.totalVotesReceived),
                backgroundColor: 'rgba(249, 122, 61, 0.7)',
                borderColor: 'rgba(249, 122, 61, 1)',
                borderWidth: 2, borderRadius: 5,
            }]
        },
        options: {
            indexAxis: 'y', responsive: true, maintainAspectRatio: false,
            animation: {
                duration: 1500, 
                delay: (context) => {
                    if (context.type !== 'data') return 0;
                    return context.dataIndex * 500;
                }
            },
            layout: { padding: { left: 45 } },
            plugins: {
                legend: { display: false },
                tooltip: { callbacks: { label: (context) => `${context.raw} votes received` } },
            },
            scales: {
                x: { beginAtZero: true, grid: { color: 'rgba(74, 47, 72, 0.1)' }, ticks: { precision: 0 } },
                y: { grid: { display: false } }
            }
        },
        plugins: [avatarLabelsPlugin]
    });
}

/**
 * Renders the vote heatmap table with a cascading fade-in animation for each cell.
 * @param {object} playerStats - The player statistics object.
 * @param {string[]} playerIds - An array of all player IDs.
 */
function renderHeatmap(playerStats, playerIds) {
    const container = document.getElementById('heatmap-container');
    container.innerHTML = '';
    const table = document.createElement('table');

    const header = table.createTHead().insertRow();
    header.insertCell().innerHTML = 'Voter<br>‚Üì';
    playerIds.forEach(targetId => {
        const th = document.createElement('th');
        th.innerHTML = `<img src="${playerStats[targetId].avatarSrc}" alt="${playerStats[targetId].pseudo}" class="player-avatar"><span>${playerStats[targetId].pseudo}</span>`;
        header.appendChild(th);
    });
    const tbody = table.createTBody();
    playerIds.forEach(voterId => {
        const row = tbody.insertRow();
        const th = document.createElement('th');
        th.className = 'voter-header';
        th.innerHTML = `<img src="${playerStats[voterId].avatarSrc}" alt="${playerStats[voterId].pseudo}" class="player-avatar"><span>${playerStats[voterId].pseudo}</span>`;
        row.appendChild(th);
        playerIds.forEach(targetId => {
            const cell = row.insertCell();
            if (voterId === targetId) {
                cell.className = 'is-self';
                cell.innerHTML = '‚Äî';
                cell.style.opacity = 1; 
            } else {
                const votes = playerStats[voterId].votesCast[targetId] || 0;
                cell.textContent = votes > 0 ? votes : '';
                cell.dataset.votes = votes;
                if (votes >= 4) cell.classList.add('hot');
            }
        });
    });

    container.appendChild(table);

    const cellsToAnimate = table.querySelectorAll('td:not(.is-self)');

   
    cellsToAnimate.forEach((cell, index) => {
        const delay = index * 15; 
        cell.style.animation = `fadeInCell 0.4s ${delay}ms ease-out forwards`;
    });
}

/**
 * Renders a stacked bar chart showing the composition of each player's votes.
 * Includes a custom HTML legend with player avatars.
 * @param {object} playerStats - The player statistics object.
 */
function renderStackedVoteChart(playerStats) {
    const voters = Object.values(playerStats);
    const targets = Object.values(playerStats);
    
    const datasets = targets.map((target, index) => ({
        label: target.pseudo,
        data: voters.map(voter => voter.votesCast[target.id] || 0),
        backgroundColor: CHART_PALETTE[index % CHART_PALETTE.length],
        borderColor: THEME_COLORS.purple,
        borderWidth: 2,
        borderRadius: 3
    }));
    
    const ctx = document.getElementById('stackedVoteChart').getContext('2d');
    const chart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: voters.map(voter => voter.pseudo),
            datasets: datasets
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: {
                legend: { display: false }, 
                tooltip: {
                    ...CHART_DEFAULTS.tooltip,
                    callbacks: {
                        label: function(context) {
                            const voterName = context.chart.data.labels[context.dataIndex];
                            const targetName = context.dataset.label;
                            const voteCount = context.raw;
                            return voteCount > 0 ? `${voterName} -> ${targetName}: ${voteCount} vote(s)` : null;
                        }
                    }
                }
            },
            scales: {
                x: { stacked: true, grid: { display: false }, ticks: { font: CHART_DEFAULTS.font } },
                y: {
                    stacked: true, beginAtZero: true,
                    title: { display: true, text: 'Total Votes Cast by Player', font: CHART_DEFAULTS.font },
                    ticks: { precision: 0, font: CHART_DEFAULTS.font },
                    grid: { color: THEME_COLORS.gridColor }
                }
            },
            animation: {
                duration: 1500,
                delay: (context) => context.datasetIndex * 500
            }
        }
    });
    
    const legendContainer = document.getElementById('stacked-chart-legend');
    legendContainer.innerHTML = '';
    chart.data.datasets.forEach((dataset, i) => {
        const targetPlayer = targets.find(p => p.pseudo === dataset.label);
        if (!targetPlayer) return;

        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        
        const colorBox = document.createElement('span');
        colorBox.className = 'legend-swatch';
        colorBox.style.backgroundColor = dataset.backgroundColor;

        const avatar = document.createElement('img');
        avatar.src = targetPlayer.avatarSrc;
        avatar.className = 'legend-avatar';

        const text = document.createElement('span');
        text.textContent = dataset.label;
        
        legendItem.appendChild(colorBox);
        legendItem.appendChild(avatar);
        legendItem.appendChild(text);
        legendContainer.appendChild(legendItem);
    });
}

/**
 * Creates an interactive network graph using Vis.js.
 * Physics are tuned to prevent node overlap and improve readability.
 * @param {object} playerStats - The player statistics object.
 */
function renderNetworkGraph(playerStats) {
    const nodes = Object.values(playerStats).map(player => ({
        id: player.id,
        shape: 'circularImage',
        image: player.avatarSrc,
        label: player.pseudo,
        size: 30,
    }));

    const edges = [];
    Object.values(playerStats).forEach(voter => {
        Object.entries(voter.votesCast).forEach(([targetId, voteCount]) => {
            if (voteCount > 0) {
                edges.push({
                    from: voter.id,
                    to: targetId,
                    value: voteCount,
                    title: `${voter.pseudo} voted for ${playerStats[targetId].pseudo} ${voteCount} times`,
                    arrows: 'to',
                });
            }
        });
    });

    const container = document.getElementById('network-graph-container');
    const data = { nodes, edges };

    const options = {
        nodes: {
            borderWidth: 3,
            color: {
                border: 'var(--clr-primary-purple)',
                background: 'var(--clr-card-bg)'
            },
            font: {
                color: 'var(--clr-text-dark)',
                face: 'Poppins',
            },
            shapeProperties: {
                useBorderWithImage: true
            }
        },
        edges: {
            color: {
                color: 'var(--clr-accent-teal)',
                highlight: 'var(--clr-primary-orange)',
                hover: 'var(--clr-primary-orange)',
            },
            width: 2,
            scaling: {
                min: 1,
                max: 12,
            },
           
            smooth: {
                type: 'dynamic', 
                roundness: 0.1
            }
        },
        
        physics: {
            enabled: true,
            solver: 'barnesHut',
            barnesHut: {
                gravitationalConstant: -15000, 
                centralGravity: 0.05, 
                springLength: 250, 
                springConstant: 0.02,
                damping: 0.09,
            },
        },
        interaction: {
            hover: true,
            tooltipDelay: 200,
        },
    };

    const network = new vis.Network(container, data, options);
    network.on("stabilizationIterationsDone", function () {
        network.setOptions( { physics: false } );
    });
}


/**
 * Renders a personal radar chart for each player, showing their strategic profile.
 * Axes are dynamically generated based on events that occurred in the game.
 * @param {object} playerStats - The player statistics object.
 * @param {object} gameFeatures - Flags indicating which game phases occurred.
 */
function renderPersonalRadars(playerStats, gameFeatures) {
    const container = document.getElementById('personal-radars-container');
    container.innerHTML = '';

    // Define all possible axes for the radar chart.
    // The tooltip description is a function to allow dynamic formatting.
    const allPossibleAxes = {
        pressure:   { label: 'Pressure', key: 'pressurePercent', description: (v) => [`Was the main target`, `in ${v}% of rounds.`] },
        solo:       { label: 'Solo Vote', key: 'soloAccusationPercent', description: (v) => [`Voted alone against a target`, `in ${v}% of rounds.`] },
        winner:     { label: 'Good Target', key: 'votedForWinnerPercent', description: (v) => [`Voted for the round's winner`, `in ${v}% of cases.`] },
        severity:   { label: 'Harsh Judge', key: 'severityPercent', description: (v) => [`Judged "not convinced"`, `in ${v}% of verdicts.`] },
        persuasion: { label: 'Persuasion', key: 'persuasionPercent', description: (v) => [`Was judged "convinced"`, `during ${v}% of confessions.`] },
        luck:       { label: 'Luck', key: 'headsPercent', description: (v) => [`Won the coin toss`, `in ${v}% of throws.`] },
    };


    // Dynamically build the list of axes to display based on what happened in the game.
    const activeAxesConfig = [
        allPossibleAxes.pressure,
        allPossibleAxes.solo,
        allPossibleAxes.winner,
    ];
    if (gameFeatures.hadConfessionJudgments) activeAxesConfig.push(allPossibleAxes.severity);
    if (gameFeatures.hadConfessionTargets) activeAxesConfig.push(allPossibleAxes.persuasion);
    if (gameFeatures.hadCoinTosses) activeAxesConfig.push(allPossibleAxes.luck);
    
    if (activeAxesConfig.length < 3) {
        container.innerHTML = `<p class="card-subtitle" style="width:100%; text-align:center;">Pas assez de donn√©es pour un bilan de joueur d√©taill√© sur cette partie.</p>`;
        return;
    }

    const chartLabels = activeAxesConfig.map(axis => axis.label);

    Object.values(playerStats).forEach(player => {
        const card = document.createElement('div');
        card.className = 'radar-card';
        
        card.innerHTML = `
            <div class="radar-player-info">
                <img src="${player.avatarSrc}" alt="${player.pseudo}" class="radar-player-avatar">
                <span>Profil de ${player.pseudo}</span>
            </div>
            <div class="radar-chart-container">
                <canvas id="radar-chart-${player.id}"></canvas>
            </div>
        `;
        container.appendChild(card);

        const playerData = activeAxesConfig.map(axis => player[axis.key] || 0);
        const ctx = document.getElementById(`radar-chart-${player.id}`).getContext('2d');

        new Chart(ctx, {
            type: 'radar',
            data: {
                labels: chartLabels,
                datasets: [{
                    label: player.pseudo,
                    data: playerData,
                    backgroundColor: 'rgba(249, 122, 61, 0.4)',
                    borderColor: 'rgba(249, 122, 61, 1)',
                    borderWidth: 2,
                    pointBackgroundColor: 'rgba(249, 122, 61, 1)',
                }]
            },
           options: {
                responsive: true,
                maintainAspectRatio: true,
                layout: {
                    padding: 20
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        ...CHART_DEFAULTS.tooltip,
                        callbacks: {
                            title: function(tooltipItems) {
                                return tooltipItems[0].label;
                            },
                            label: function(context) {
                                const axisIndex = context.dataIndex;
                                const axisConfig = activeAxesConfig[axisIndex];
                                const value = Math.round(context.raw);
                                return axisConfig.description(value);
                            }
                        }
                    }
                },
                scales: {
                    r: {
                        beginAtZero: true, max: 100,
                        angleLines: { color: THEME_COLORS.gridColor },
                        grid: { color: THEME_COLORS.gridColor },
                        pointLabels: {
                            font: { ...CHART_DEFAULTS.font, size: 10, weight: '600' }, 
                            color: THEME_COLORS.green
                        },
                        ticks: {
                            display: false,
                            stepSize: 25,
                        }
                    }
                },
                animation: { duration: 3000, easing: 'easeOutQuart' }
            }
        });
    });
}
</script>